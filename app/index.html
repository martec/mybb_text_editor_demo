<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        
        <title>MyBB Text Editor Demo</title>
    </head>
    <body>
        <h1>MyBB Text Editor Demo</h1>

        <p class="muted">This is a demo for what could potentially become the text editor in MyBB 1.9.0.</p>

        <div id="app"></div>

        <!-- NOTE: This is generated by the `index.php` script, we'd normally extract this out... -->
        <script>(function(){/** @const */ var HINT={};
                /** @const */ HINT.RULE_AUTO_CLOSE=1;
                /** @const */ HINT.RULE_AUTO_REOPEN=1;
                /** @const */ HINT.RULE_BREAK_PARAGRAPH=0;
                /** @const */ HINT.RULE_CREATE_PARAGRAPHS=0;
                /** @const */ HINT.RULE_DISABLE_AUTO_BR=1;
                /** @const */ HINT.RULE_ENABLE_AUTO_BR=1;
                /** @const */ HINT.RULE_IGNORE_TAGS=1;
                /** @const */ HINT.RULE_IGNORE_TEXT=1;
                /** @const */ HINT.RULE_IGNORE_WHITESPACE=1;
                /** @const */ HINT.RULE_IS_TRANSPARENT=1;
                /** @const */ HINT.RULE_PREVENT_BR=1;
                /** @const */ HINT.RULE_SUSPEND_AUTO_BR=1;
                /** @const */ HINT.RULE_TRIM_FIRST_LINE=1;
                /** @const */ HINT.attributeDefaultValue=1;
                /** @const */ HINT.closeAncestor=0;
                /** @const */ HINT.closeParent=1;
                /** @const */ HINT.createChild=1;
                /** @const */ HINT.fosterParent=1;
                /** @const */ HINT.ignoreAttrs=1;
                /** @const */ HINT.namespaces=0;
                /** @const */ HINT.postProcessing=1;
                /** @const */ HINT.requireAncestor=0;
                /** @const */ var oB4E9AE58=[""];
                /** @const */ var o57F7F446=[1542];
                /** @const */ var oB14C3B08=[1539];
                /** @const */ var oDA7900A1=[32591];
                /** @const */ var oF6AF222C=[32623];
                /** @const */ var o90B2B224=["","t"];
                /** @const */ var o85888FAE=["","id"];
                /** @const */ var oB565876D={flags:2};
                /** @const */ var oA80287CC={flags:3089};
                /** @const */ var o1BC3EAF4={filterChain:[],required:!1};
                /** @const */ var oF4E3480F={"B":1,"COLOR":1,"EM":1,"FONT":1,"I":1,"S":1,"SIZE":1,"U":1,"URL":1};
                /** @const */ var o63C22C4F=[/**
                * @param {*} attrValue
                * @param {!string} attrName
                */
                function(attrValue,attrName){return NumericFilter.filterUint(attrValue);}];
                /** @const */ var o1B3CF9D3=[/**
                * @param {!Tag} tag
                * @param {!Object} tagConfig
                */
                function(tag,tagConfig){return filterAttributes(tag,tagConfig,registeredVars,logger);}];
                /** @const */ var o73D8BCD7={filterChain:[/**
                * @param {*} attrValue
                * @param {!string} attrName
                */
                function(attrValue,attrName){return TimestampFilter.filter(attrValue);}],required:!1};
                /** @const */ var o730E3161={filterChain:o63C22C4F,required:!1};
                /** @const */ var oC59E07AC={filterChain:[/**
                * @param {*} attrValue
                * @param {!string} attrName
                */
                function(attrValue,attrName){return RegexpFilter.filter(attrValue,/^[-0-9A-Za-z_]+$/);}],required:!1};
                /** @const */ var oEB3B7BEF={closeParent:oF4E3480F,flags:256,fosterParent:oF4E3480F};
                /** @const */ var o0F509AAD={filterChain:[/**
                * @param {*} attrValue
                * @param {!string} attrName
                */
                function(attrValue,attrName){return UrlFilter.filter(attrValue,registeredVars["urlConfig"],logger);}],required:!0};
                /** @const */ var oAD0E5492={allowed:oDA7900A1,attributes:{},bitNumber:6,filterChain:o1B3CF9D3,nestingLimit:10,rules:oB565876D,tagLimit:5000};
                /** @const */ var oBFF5DAF4={allowed:oB14C3B08,attributes:{"id":o1BC3EAF4},bitNumber:3,filterChain:o1B3CF9D3,nestingLimit:10,rules:oA80287CC,tagLimit:5000};
                /** @const */ var o2E4CE47C={allowed:o57F7F446,attributes:{"char":{filterChain:[],required:!0}},bitNumber:1,filterChain:o1B3CF9D3,nestingLimit:10,rules:oA80287CC,tagLimit:5000};
                /** @const */ var xsl="<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http:\/\/www.w3.org\/1999\/XSL\/Transform\"><xsl:output method=\"html\" encoding=\"utf-8\" indent=\"no\"\/>$aALIGN\"><div$itext-align:{@align}\">$e<\/div>$d$aB|EM|I|LI|S|U|p\"><xsl:element$r{translate(name(),'BEILMSU','beilmsu')}\">$e<\/xsl:element>$d$aCODE\"><pre data-hljs=\"\" data-s9e-livepreview-postprocess=\"if('undefined'!==typeof hljs)hljs._hb(this)\"><code><$q$m@lang\"><$n$rclass\">language-$c@lang\"\/><\/$n><\/$q>$e<\/code><\/pre><script>if(\"undefined\"!==typeof hljs)hljs._ha();else if(\"undefined\"===typeof hljsLoading){hljsLoading=1;var a=document.getElementsByTagName(\"head\")[0],e=document.createElement(\"link\");e.type=\"text\/css\";e.rel=\"stylesheet\";e.href=\"\/\/cdnjs.cloudflare.com\/ajax\/libs\/highlight.js\/9.7.0\/styles\/default.min.css\";a.appendChild(e);e=document.createElement(\"script\");e.type=\"text\/javascript\";e.onload=function(){var d={},f=0;hljs._hb=function(b){b.removeAttribute(\"data-hljs\");var c=b.innerHTML;c in d?b.innerHTML=d[c]:(7&lt;++f&amp;&amp;(d={},f=0),hljs.highlightBlock(b.firstChild),d[c]=b.innerHTML)};hljs._ha=function(){for(var b=document.querySelectorAll(\"pre[data-hljs]\"),c=b.length;0&lt;c;)hljs._hb(b.item(--c))};hljs._ha()};e.async=!0;e.src=\"\/\/cdnjs.cloudflare.com\/ajax\/libs\/highlight.js\/9.7.0\/highlight.min.js\";a.appendChild(e)}<\/script>$d$aCOLOR\"><$y$icolor:{@color}\">$e<\/$y>$d$aFACEBOOK\"><iframe$ffacebook\"$o\"$lstyle\"$x$b$tno\" src=\"https:\/\/s9e.github.io\/iframe\/2\/facebook.min.html#{@type}{@id}\"$iborder:0;height:360px;max-width:640px;width:100%\"\/>$d$aFONT\"><$y$ifont-family:{@font}\">$e<\/$y>$d$aFP|HE\">$c@char\"\/>$d$aGFYCAT\"><$y$fgfycat\"$i$h{@width}px\"><$y><$n$rstyle\">display:block;overflow:hidden;position:relative;<$q$m@width&gt;0\">padding-bottom:$c100*(@height+44)div@width\"\/>%;padding-bottom:calc($c100*@height div@width\"\/>% + 44px)<\/$q><\/$n>$j src=\"\/\/gfycat.com\/ifr\/{@id}\"$i$k\/><\/$y><\/$y>$d$aIMG\"><img src=\"{@src}\" title=\"{@title}\" alt=\"{@alt}\">$pheight|@width\"\/><\/img>$d$aIMGUR\"><iframe$fimgur\"$o\"$lstyle\"$xvar c=new MessageChannel;c.port1.onmessage=function(e){{var d=e.data.split(' ');style.height=d[0]+'px';style.width=d[1]+'px'}};contentWindow.postMessage('s9e:init','https:\/\/s9e.github.io',[c.port2])\"$tno\"$iborder:0;height:400px;max-width:100%;width:542px\"><$n$rsrc\">https:\/\/s9e.github.io\/iframe\/2\/imgur.min.html#<$q$m@type='album'\">a\/<\/$q>$c@id\"\/><\/$n><\/iframe>$d$aLIST\"><$u><$v$mnot(@type)\"><ul>$e<\/ul><\/$v><$v$mstarts-with(@type,'decimal')or starts-with(@type,'lower')or starts-with(@type,'upper')\"><ol$i$w>$pstart\"\/>$e<\/ol><\/$v><$s><ul$i$w>$e<\/ul><\/$s><\/$u>$d$aQUOTE\"><blockquote><$q$mnot(@author)\"><$n$rclass\">uncited<\/$n><\/$q><div><$q$m@author\"><cite>$c@author\"\/> wrote:<\/cite><\/$q>$e<\/div><\/blockquote>$d$aREDDIT\"><iframe$freddit\"$o\"$lstyle\"$x$b$tno\" src=\"https:\/\/s9e.github.io\/iframe\/2\/reddit.min.html#{@id}{@path}\"$iborder:0;height:165px;max-width:800px;width:100%\"\/>$d$aSIZE\"><$y$ifont-size:{@size}px\">$e<\/$y>$d$aTWITCH\"><$y$ftwitch\"$i$h640px\"><$y$i$g56.25%\">$j$i$k><$n$rsrc\">\/\/<$u><$v$m@clip_id\">clips.twitch.tv\/embed?autoplay=false&amp;clip=<$q$m@channel\">$c@channel\"\/>\/<\/$q>$c@clip_id\"\/><\/$v><$s>player.twitch.tv\/?autoplay=false&amp;<$u><$v$m@video_id\">video=v$c@video_id\"\/><\/$v><$s>channel=$c@channel\"\/><\/$s><\/$u><$q$m@t\">&amp;time=$c@t\"\/><\/$q><\/$s><\/$u><\/$n><\/iframe><\/$y><\/$y>$d$aTWITTER\"><iframe$ftwitter\" allow=\"autoplay *\"$o\"$lstyle\"$x$b$tno\" src=\"https:\/\/s9e.github.io\/iframe\/2\/twitter.min.html#{@id}\"$ibackground:url(https:\/\/abs.twimg.com\/favicons\/favicon.ico) no-repeat 50% 50%;border:0;height:250px;max-width:500px;width:100%\"\/>$d$aURL\"><a href=\"{@url}\">$ptitle\"\/>$e<\/a>$d$aVIMEO\"><$y$fvimeo\"$i$h640px\"><$y$i$g56.25%\">$j$i$k><$n$rsrc\">\/\/player.vimeo.com\/video\/$c@id\"\/><$q$m@t\">#t=$c@t\"\/><\/$q><\/$n><\/iframe><\/$y><\/$y>$d$aYOUTUBE\"><$y$fyoutube\"$i$h640px\"><$y$i$g56.25%\">$j$ibackground:url(https:\/\/i.ytimg.com\/vi\/{@id}\/hqdefault.jpg) 50% 50% \/ cover;$k><$n$rsrc\">https:\/\/www.youtube.com\/embed\/$c@id\"\/><$q$m@list\">?list=$c@list\"\/><\/$q><$q$m@t\"><$u><$v$m@list\">&amp;<\/$v><$s>?<\/$s><\/$u>start=$c@t\"\/><\/$q><\/$n><\/iframe><\/$y><\/$y>$d$abr\"><br\/>$d$ae|i|s\"\/><\/xsl:stylesheet>".replace(/\$[a-y]/g,function(k){return{"$a":"<xsl:template match=\"","$b":"var c=new MessageChannel;c.port1.onmessage=function(e){{style.height=e.data+'px'}};contentWindow.postMessage('s9e:init','https:\/\/s9e.github.io',[c.port2])\"","$c":"<xsl:value-of select=\"","$d":"<\/xsl:template>","$e":"<xsl:apply-templates\/>","$f":" data-s9e-mediaembed=\"","$g":"display:block;overflow:hidden;position:relative;padding-bottom:","$h":"display:inline-block;width:100%;max-width:","$i":" style=\"","$j":"<iframe allowfullscreen=\"\" scrolling=\"no\"","$k":"border:0;height:100%;left:0;position:absolute;width:100%\"","$l":" data-s9e-livepreview-ignore-attrs=\"","$m":" test=\"","$n":"xsl:attribute","$o":" allowfullscreen=\"","$p":"<xsl:copy-of select=\"@","$q":"xsl:if","$r":" name=\"","$s":"xsl:otherwise","$t":" scrolling=\"","$u":"xsl:choose","$v":"xsl:when","$w":"list-style-type:{@type}\"","$x":" onload=\"","$y":"span"}[k]});
                /** @const */
                var EmailFilter =
                {
                    /**
                    * @param  {*} attrValue
                    * @return {*}
                    */
                    filter: function(attrValue)
                    {
                        return /^[-\w.+]+@[-\w.]+$/.test(attrValue) ? attrValue : false;
                    }
                };
                /** @const */
                var FalseFilter =
                {
                    /**
                    * @param  {*} attrValue
                    * @return {!boolean}
                    */
                    filter: function(attrValue)
                    {
                        return false;
                    }
                };
                /** @const */
                var HashmapFilter =
                {
                    /**
                    * @param  {*}        attrValue Original value
                    * @param  {!Object}  map       Hash map
                    * @param  {!boolean} strict    Whether this map is strict (values with no match are invalid)
                    * @return {*}                  Filtered value, or FALSE if invalid
                    */
                    filter: function(attrValue, map, strict)
                    {
                        if (attrValue in map)
                        {
                            return map[attrValue];
                        }
                
                        return (strict) ? false : attrValue;
                    }
                };
                /** @const */
                var MapFilter =
                {
                    /**
                    * @param  {*} attrValue
                    * @param  {!Array.<!Array>}  map
                    * @return {*}
                    */
                    filter: function(attrValue, map)
                    {
                        var i = -1, cnt = map.length;
                        while (++i < cnt)
                        {
                            if (map[i][0].test(attrValue))
                            {
                                return map[i][1];
                            }
                        }
                
                        return attrValue;
                    }
                };
                /** @const */
                var NetworkFilter =
                {
                    /**
                    * @param  {*} attrValue
                    * @return {*}
                    */
                    filterIp: function(attrValue)
                    {
                        if (/^[\d.]+$/.test(attrValue))
                        {
                            return NetworkFilter.filterIpv4(attrValue);
                        }
                
                        if (/^[\da-f:]+$/i.test(attrValue))
                        {
                            return NetworkFilter.filterIpv6(attrValue);
                        }
                
                        return false;
                    },
                
                    /**
                    * @param  {*} attrValue
                    * @return {*}
                    */
                    filterIpport: function(attrValue)
                    {
                        var m, ip;
                
                        if (m = /^\[([\da-f:]+)(\]:[1-9]\d*)$/i.exec(attrValue))
                        {
                            ip = NetworkFilter.filterIpv6(m[1]);
                
                            if (ip === false)
                            {
                                return false;
                            }
                
                            return '[' + ip + m[2];
                        }
                
                        if (m = /^([\d.]+)(:[1-9]\d*)$/.exec(attrValue))
                        {
                            ip = NetworkFilter.filterIpv4(m[1]);
                
                            if (ip === false)
                            {
                                return false;
                            }
                
                            return ip + m[2];
                        }
                
                        return false;
                    },
                
                    /**
                    * @param  {*} attrValue
                    * @return {*}
                    */
                    filterIpv4: function(attrValue)
                    {
                        if (!/^\d+\.\d+\.\d+\.\d+$/.test(attrValue))
                        {
                            return false;
                        }
                
                        var i = 4, p = attrValue.split('.');
                        while (--i >= 0)
                        {
                            // NOTE: ext/filter doesn't support octal notation
                            if (p[i][0] === '0' || p[i] > 255)
                            {
                                return false;
                            }
                        }
                
                        return attrValue;
                    },
                
                    /**
                    * @param  {*} attrValue
                    * @return {*}
                    */
                    filterIpv6: function(attrValue)
                    {
                        return /^([\da-f]{0,4}:){2,7}(?:[\da-f]{0,4}|\d+\.\d+\.\d+\.\d+)$/.test(attrValue) ? attrValue : false;
                    }
                };
                /** @const */
                var NumericFilter =
                {
                    /**
                    * @param  {*} attrValue
                    * @return {*}
                    */
                    filterFloat: function(attrValue)
                    {
                        return /^(?:0|-?[1-9]\d*)(?:\.\d+)?(?:e[1-9]\d*)?$/i.test(attrValue) ? attrValue : false;
                    },
                
                    /**
                    * @param  {*} attrValue
                    * @return {*}
                    */
                    filterInt: function(attrValue)
                    {
                        return /^(?:0|-?[1-9]\d*)$/.test(attrValue) ? attrValue : false;
                    },
                
                    /**
                    * @param  {*}       attrValue
                    * @param  {!number} min
                    * @param  {!number} max
                    * @param  {Logger}  logger
                    * @return {!number|boolean}
                    */
                    filterRange: function(attrValue, min, max, logger)
                    {
                        if (!/^(?:0|-?[1-9]\d*)$/.test(attrValue))
                        {
                            return false;
                        }
                
                        attrValue = parseInt(attrValue, 10);
                
                        if (attrValue < min)
                        {
                            if (logger)
                            {
                                logger.warn(
                                    'Value outside of range, adjusted up to min value',
                                    {
                                        'attrValue' : attrValue,
                                        'min'       : min,
                                        'max'       : max
                                    }
                                );
                            }
                
                            return min;
                        }
                
                        if (attrValue > max)
                        {
                            if (logger)
                            {
                                logger.warn(
                                    'Value outside of range, adjusted down to max value',
                                    {
                                        'attrValue' : attrValue,
                                        'min'       : min,
                                        'max'       : max
                                    }
                                );
                            }
                
                            return max;
                        }
                
                        return attrValue;
                    },
                
                    /**
                    * @param  {*} attrValue
                    * @return {*}
                    */
                    filterUint: function(attrValue)
                    {
                        return /^(?:0|[1-9]\d*)$/.test(attrValue) ? attrValue : false;
                    }
                };
                /** @const */
                var RegexpFilter =
                {
                    /**
                    * @param  {*} attrValue
                    * @param  {!RegExp} regexp
                    * @return {*}
                    */
                    filter: function(attrValue, regexp)
                    {
                        return regexp.test(attrValue) ? attrValue : false;
                    }
                };
                /** @const */
                var TimestampFilter =
                {
                    /**
                    * @param  {*} attrValue
                    * @return {*}
                    */
                    filter: function(attrValue)
                    {
                        var m = /^(?=\d)(?:(\d+)h)?(?:(\d+)m)?(?:(\d+)s)?$/.exec(attrValue);
                        if (m)
                        {
                            return 3600 * (m[1] || 0) + 60 * (m[2] || 0) + (+m[3] || 0);
                        }
                
                        return NumericFilter.filterUint(attrValue);
                    }
                };
                /** @const */
                var UrlFilter =
                {
                    /**
                    * @param  {*} attrValue
                    * @param  {!Object} urlConfig
                    * @param  {Logger} logger
                    * @return {*}
                    */
                    filter: function(attrValue, urlConfig, logger)
                    {
                        /**
                        * Trim the URL to conform with HTML5 then parse it
                        * @link http://dev.w3.org/html5/spec/links.html#attr-hyperlink-href
                        */
                        var p = UrlFilter.parseUrl(attrValue.replace(/^\s+/, '').replace(/\s+$/, ''));
                
                        var error = UrlFilter.validateUrl(urlConfig, p);
                        if (error)
                        {
                            if (logger)
                            {
                                p['attrValue'] = attrValue;
                                logger.err(error, p);
                            }
                
                            return false;
                        }
                
                        return UrlFilter.rebuildUrl(urlConfig, p);
                    },
                
                    /**
                    * Parse a URL and return its components
                    *
                    * Similar to PHP's own parse_url() except that all parts are always returned
                    *
                    * @param  {!string} url Original URL
                    * @return {!Object}
                    */
                    parseUrl: function(url)
                    {
                        var regexp = /^(?:([a-z][-+.\w]*):)?(?:\/\/(?:([^:\/?#]*)(?::([^\/?#]*)?)?@)?(?:(\[[a-f\d:]+\]|[^:\/?#]+)(?::(\d*))?)?(?![^\/?#]))?([^?#]*)(\?[^#]*)?(#.*)?$/i;
                
                        // NOTE: this regexp always matches because of the last three captures
                        var m = regexp['exec'](url),
                            parts = {},
                            tokens = ['scheme', 'user', 'pass', 'host', 'port', 'path', 'query', 'fragment'];
                        tokens.forEach(
                            function(name, i)
                            {
                                parts[name] = (m[i + 1] > '') ? m[i + 1] : '';
                            }
                        );
                
                        /**
                        * @link http://tools.ietf.org/html/rfc3986#section-3.1
                        *
                        * 'An implementation should accept uppercase letters as equivalent to lowercase in
                        * scheme names (e.g., allow "HTTP" as well as "http") for the sake of robustness but
                        * should only produce lowercase scheme names for consistency.'
                        */
                        parts['scheme'] = parts['scheme'].toLowerCase();
                
                        /**
                        * Normalize the domain label separators and remove trailing dots
                        * @link http://url.spec.whatwg.org/#domain-label-separators
                        */
                        parts['host'] = parts['host'].replace(/[\u3002\uff0e\uff61]/g, '.').replace(/\.+$/g, '');
                
                        // Test whether host has non-ASCII characters and punycode it if possible
                        if (/[^\x00-\x7F]/.test(parts['host']) && typeof punycode !== 'undefined')
                        {
                            parts['host'] = punycode.toASCII(parts['host']);
                        }
                
                        return parts;
                    },
                
                    /**
                    * Rebuild a parsed URL
                    *
                    * @param  {!Object} urlConfig
                    * @param  {!Object} p
                    * @return {!string}
                    */
                    rebuildUrl: function(urlConfig, p)
                    {
                        var url = '';
                        if (p['scheme'] !== '')
                        {
                            url += p['scheme'] + ':';
                        }
                        if (p['host'] === '')
                        {
                            // Allow the file: scheme to not have a host and ensure it starts with slashes
                            if (p['scheme'] === 'file')
                            {
                                url += '//';
                            }
                        }
                        else
                        {
                            url += '//';
                
                            // Add the credentials if applicable
                            if (p['user'] !== '')
                            {
                                // Reencode the credentials in case there are invalid chars in them, or suspicious
                                // characters such as : or @ that could confuse a browser into connecting to the
                                // wrong host (or at least, to a host that is different than the one we thought)
                                url += rawurlencode(decodeURIComponent(p['user']));
                
                                if (p['pass'] !== '')
                                {
                                    url += ':' + rawurlencode(decodeURIComponent(p['pass']));
                                }
                
                                url += '@';
                            }
                
                            url += p['host'];
                
                            // Append the port number (note that as per the regexp it can only contain digits)
                            if (p['port'] !== '')
                            {
                                url += ':' + p['port'];
                            }
                        }
                
                        // Build the path, including the query and fragment parts
                        var path = p['path'] + p['query'] + p['fragment'];
                
                        /**
                        * "For consistency, URI producers and normalizers should use uppercase hexadecimal digits
                        * for all percent- encodings."
                        *
                        * @link http://tools.ietf.org/html/rfc3986#section-2.1
                        */
                        path = path.replace(
                            /%.?[a-f]/g,
                            function (str)
                            {
                                return str.toUpperCase();
                            },
                            path
                        );
                
                        // Append the sanitized path to the URL
                        url += UrlFilter.sanitizeUrl(path);
                
                        // Replace the first colon if there's no scheme and it could potentially be interpreted as
                        // the scheme separator
                        if (!p['scheme'])
                        {
                            url = url.replace(/^([^\/]*):/, '$1%3A');
                        }
                
                        return url;
                    },
                
                    /**
                    * Sanitize a URL for safe use regardless of context
                    *
                    * This method URL-encodes some sensitive characters in case someone would want to use the URL in
                    * some JavaScript thingy, or in CSS. We also encode characters that are not allowed in the path
                    * of a URL as defined in RFC 3986 appendix A, including percent signs that are not immediately
                    * followed by two hex digits.
                    *
                    * " and ' to prevent breaking out of quotes (JavaScript or otherwise)
                    * ( and ) to prevent the use of functions in JavaScript (eval()) or CSS (expression())
                    * < and > to prevent breaking out of <script>
                    * \r and \n because they're illegal in JavaScript
                    * [ and ] because the W3 validator rejects them and they "should" be escaped as per RFC 3986
                    * Non-ASCII characters as per RFC 3986
                    * Control codes and spaces, as per RFC 3986
                    *
                    * @link http://sla.ckers.org/forum/read.php?2,51478
                    * @link http://timelessrepo.com/json-isnt-a-javascript-subset
                    * @link http://www.ietf.org/rfc/rfc3986.txt
                    * @link http://stackoverflow.com/a/1547922
                    * @link http://tools.ietf.org/html/rfc3986#appendix-A
                    *
                    * @param  {!string} url Original URL
                    * @return {!string}     Sanitized URL
                    */
                    sanitizeUrl: function(url)
                    {
                        return url.replace(/[^\u0020-\u007E]+/g, encodeURIComponent).replace(/%(?![0-9A-Fa-f]{2})|[^!#-&*-;=?-Z_a-z~]/g, escape);
                    },
                
                    /**
                    * Validate a parsed URL
                    *
                    * @param  {!Object} urlConfig
                    * @param  {!Object} p
                    * @return {string|undefined}
                    */
                    validateUrl: function(urlConfig, p)
                    {
                        if (p['scheme'] !== '' && !urlConfig.allowedSchemes.test(p['scheme']))
                        {
                            return 'URL scheme is not allowed';
                        }
                
                        if (p['host'] === '')
                        {
                            // Reject malformed URLs such as http:///example.org but allow schemeless paths
                            if (p['scheme'] !== 'file' && p['scheme'] !== '')
                            {
                                return 'Missing host';
                            }
                        }
                        else
                        {
                            /**
                            * Test whether the host is valid
                            * @link http://tools.ietf.org/html/rfc1035#section-2.3.1
                            * @link http://tools.ietf.org/html/rfc1123#section-2
                            */
                            var regexp = /^(?!-)[-a-z0-9]{0,62}[a-z0-9](?:\.(?!-)[-a-z0-9]{0,62}[a-z0-9])*$/i;
                            if (!regexp.test(p['host']))
                            {
                                // If the host invalid, retest as an IPv4 and IPv6 address (IPv6 in brackets)
                                if (!NetworkFilter.filterIpv4(p['host'])
                                 && !NetworkFilter.filterIpv6(p['host'].replace(/^\[(.*)\]$/, '$1', p['host'])))
                                {
                                    return 'URL host is invalid';
                                }
                            }
                
                            if ((urlConfig.disallowedHosts && urlConfig.disallowedHosts.test(p['host']))
                             || (urlConfig.restrictedHosts && !urlConfig.restrictedHosts.test(p['host'])))
                            {
                                return 'URL host is not allowed';
                            }
                        }
                    }
                };
                /**
                * @param  {!string} str
                * @return {!string}
                */
                function html_entity_decode(str)
                {
                    var b = document.createElement('b');
                    html_entity_decode = function (str)
                    {
                        // We escape left brackets so that we don't inadvertently evaluate some nasty HTML such as
                        // <img src=... onload=evil() />
                        b.innerHTML = str.replace(/</g, '&lt;');
                
                        return b.textContent;
                    };
                
                    return html_entity_decode(str);
                }
                
                /**
                * @param  {!string} str
                * @return {!string}
                */
                function htmlspecialchars_compat(str)
                {
                    var t = {
                        '<' : '&lt;',
                        '>' : '&gt;',
                        '&' : '&amp;',
                        '"' : '&quot;'
                    };
                    return str.replace(
                        /[<>&"]/g,
                        /**
                        * @param {!string} c
                        */
                        function(c)
                        {
                            return t[c];
                        }
                    );
                }
                
                /**
                * @param  {!string} str
                * @return {!string}
                */
                function htmlspecialchars_noquotes(str)
                {
                    var t = {
                        '<' : '&lt;',
                        '>' : '&gt;',
                        '&' : '&amp;'
                    };
                    return str.replace(
                        /[<>&]/g,
                        /**
                        * @param {!string} c
                        */
                        function(c)
                        {
                            return t[c];
                        }
                    );
                }
                
                /**
                * @param  {!string} str
                * @return {!string}
                */
                function rawurlencode(str)
                {
                    return encodeURIComponent(str).replace(
                        /[!'()*]/g,
                        /**
                        * @param {!string} c
                        */
                        function(c)
                        {
                            return '%' + c.charCodeAt(0).toString(16).toUpperCase();
                        }
                    );
                }
                
                /**
                * @return {!boolean}
                */
                function returnFalse()
                {
                    return false;
                }
                
                /**
                * @return {!boolean}
                */
                function returnTrue()
                {
                    return true;
                }
                /**
                * Execute all the attribute preprocessors of given tag
                *
                * @private
                *
                * @param {!Tag}    tag       Source tag
                * @param {!Object} tagConfig Tag's config
                */
                function executeAttributePreprocessors(tag, tagConfig)
                {
                    if (!tagConfig.attributePreprocessors)
                    {
                        return;
                    }
                
                    tagConfig.attributePreprocessors.forEach(function(ap)
                    {
                        var attrName = ap[0], regexp = ap[1], map = ap[2];
                        if (tag.hasAttribute(attrName))
                        {
                            executeAttributePreprocessor(tag, attrName, regexp, map);
                        }
                    });
                }
                
                /**
                * Filter the attributes of given tag
                *
                * @private
                *
                * @param {!Tag}    tag            Tag being checked
                * @param {!Object} tagConfig      Tag's config
                * @param {!Object} registeredVars Unused
                * @param {!Logger} logger         This parser's Logger instance
                */
                function filterAttributes(tag, tagConfig, registeredVars, logger)
                {
                    var attributes = {}, attrName;
                    for (attrName in tagConfig.attributes)
                    {
                        var attrConfig = tagConfig.attributes[attrName],
                            attrValue  = false;
                        if (tag.hasAttribute(attrName))
                        {
                            attrValue = executeAttributeFilterChain(attrConfig.filterChain, attrName, tag.getAttribute(attrName));
                        }
                
                        if (attrValue !== false)
                        {
                            attributes[attrName] = attrValue;
                        }
                        else if (HINT.attributeDefaultValue && attrConfig.defaultValue !== undefined)
                        {
                            attributes[attrName] = attrConfig.defaultValue;
                        }
                        else if (attrConfig.required)
                        {
                            tag.invalidate();
                        }
                    }
                    tag.setAttributes(attributes);
                }
                
                /**
                * Execute a tag's filterChain
                *
                * @private
                *
                * @param {!Tag} tag Tag to filter
                */
                function filterTag(tag)
                {
                    var tagName   = tag.getName(),
                        tagConfig = tagsConfig[tagName];
                
                    // Record the tag being processed into the logger it can be added to the context of
                    // messages logged during the execution
                    logger.setTag(tag);
                
                    for (var i = 0; i < tagConfig.filterChain.length; ++i)
                    {
                        if (tag.isInvalid())
                        {
                            break;
                        }
                        tagConfig.filterChain[i](tag, tagConfig);
                    }
                
                    // Remove the tag from the logger
                    logger.unsetTag();
                }
                
                /**
                * Execute an attribute's filterChain
                *
                * @param  {!Array} filterChain Attribute's filterChain
                * @param  {string} attrName    Attribute's name
                * @param  {*}      attrValue   Original value
                * @return {*}                  Filtered value
                */
                function executeAttributeFilterChain(filterChain, attrName, attrValue)
                {
                    logger.setAttribute(attrName);
                    for (var i = 0; i < filterChain.length; ++i)
                    {
                        // NOTE: attrValue is intentionally set as the first argument to facilitate inlining
                        attrValue = filterChain[i](attrValue, attrName);
                        if (attrValue === false)
                        {
                            break;
                        }
                    }
                    logger.unsetAttribute();
                
                    return attrValue;
                }
                
                /**
                * Execute an attribute preprocessor
                *
                * @param  {!Tag}            tag
                * @param  {!string}         attrName
                * @param  {!RegExp}         regexp
                * @param  {!Array<!string>} map
                */
                function executeAttributePreprocessor(tag, attrName, regexp, map)
                {
                    var attrValue = tag.getAttribute(attrName),
                        captures  = getNamedCaptures(attrValue, regexp, map),
                        k;
                    for (k in captures)
                    {
                        // Attribute preprocessors cannot overwrite other attributes but they can
                        // overwrite themselves
                        if (k === attrName || !tag.hasAttribute(k))
                        {
                            tag.setAttribute(k, captures[k]);
                        }
                    }
                }
                
                /**
                * Execute a regexp and return the values of the mapped captures
                *
                * @param  {!string}                  attrValue
                * @param  {!RegExp}                  regexp
                * @param  {!Array<!string>}          map
                * @return {!Object<!string,!string>}
                */
                function getNamedCaptures(attrValue, regexp, map)
                {
                    var m = regexp.exec(attrValue);
                    if (!m)
                    {
                        return [];
                    }
                
                    var values = {};
                    map.forEach(function(k, i)
                    {
                        if (typeof m[i] === 'string' && m[i] !== '')
                        {
                            values[k] = m[i];
                        }
                    });
                
                    return values;
                }
                /**@constructor*/function Logger(){}Logger.prototype={add:/**
                * Add a log entry
                *
                * @param  {!string}  type    Log type
                * @param  {!string}  msg     Log message
                * @param  {!Object=} context Log context
                */
                function(type, msg, context){},clear:/**
                * Clear the log
                */
                function(){},setAttribute:/**
                * Record the name of the attribute being processed
                *
                * @param  {!string} attrName
                */
                function(attrName){},setTag:/**
                * Record the tag being processed
                *
                * @param  {!Tag} tag
                */
                function(tag){},unsetAttribute:/**
                * Unset the name of the attribute being processed
                */
                function(){},unsetTag:/**
                * Unset the tag being processed
                */
                function(){},debug:/**
                * Add a "debug" type log entry
                *
                * @param  {!string}  msg     Log message
                * @param  {!Object=} context Log context
                */
                function(msg, context){},err:/**
                * Add an "err" type log entry
                *
                * @param  {!string}  msg     Log message
                * @param  {!Object=} context Log context
                */
                function(msg, context){},info:/**
                * Add an "info" type log entry
                *
                * @param  {!string}  msg     Log message
                * @param  {!Object=} context Log context
                */
                function(msg, context){},warn:/**
                * Add a "warn" type log entry
                *
                * @param  {!string}  msg     Log message
                * @param  {!Object=} context Log context
                */
                function(msg, context){}}
                /**
                * @constructor
                *
                * @param {!number} type     Tag's type
                * @param {!string} name     Name of the tag
                * @param {!number} pos      Position of the tag in the text
                * @param {!number} len      Length of text consumed by the tag
                * @param {number=} priority This tag's sorting tiebreaker
                */
                function Tag(type, name, pos, len, priority)
                {
                    this.type = +type;
                    this.name = name;
                    this.pos  = +pos;
                    this.len  = +len;
                    if (typeof priority !== 'undefined')
                    {
                        this.sortPriority = +priority;
                    }
                
                    this.attributes = {};
                    this.cascade    = [];
                
                    // Invalidate this tag now if any value is not a number, they could wreck
                    // havoc in other parts of the program
                    if (isNaN(type + pos + len))
                    {
                        this.invalidate();
                    }
                }
                
                /** @const */
                Tag.START_TAG = 1;
                
                /** @const */
                Tag.END_TAG = 2;
                
                /** @const */
                Tag.SELF_CLOSING_TAG = 3;
                
                /**
                * @type {!Object} Dictionary of attributes
                */
                Tag.prototype.attributes;
                
                /**
                * @type {!Array.<!Tag>} List of tags that are invalidated when this tag is invalidated
                */
                Tag.prototype.cascade;
                
                /**
                * @type {Tag} End tag that unconditionally ends this start tag
                */
                Tag.prototype.endTag;
                
                /**
                * @type {!boolean} Whether this tag is be invalid
                */
                Tag.prototype.invalid = false;
                
                /**
                * @type {!number} Length of text consumed by this tag
                */
                Tag.prototype.len;
                
                /**
                * @type {!string} Name of this tag
                */
                Tag.prototype.name;
                
                /**
                * @type {!number} Position of this tag in the text
                */
                Tag.prototype.pos;
                
                /**
                * @type {!number} Tiebreaker used when sorting identical tags
                */
                Tag.prototype.sortPriority;
                
                /**
                * @type {Tag} Start tag that is unconditionally closed this end tag
                */
                Tag.prototype.startTag;
                
                /**
                * @type {!number} Tag type
                */
                Tag.prototype.type;
                
                /**
                * Add a set of flags to this tag's
                *
                * @param {!number} flags
                */
                Tag.prototype.addFlags = function(flags)
                {
                    this.flags |= flags;
                };
                
                /**
                * Set given tag to be invalidated if this tag is invalidated
                *
                * @param {!Tag} tag
                */
                Tag.prototype.cascadeInvalidationTo = function(tag)
                {
                    this.cascade.push(tag);
                
                    // If this tag is already invalid, cascade it now
                    if (this.invalid)
                    {
                        tag.invalidate();
                    }
                };
                
                /**
                * Invalidate this tag, as well as tags bound to this tag
                */
                Tag.prototype.invalidate = function()
                {
                    // If this tag is already invalid, we can return now. This prevent infinite loops
                    if (this.invalid)
                    {
                        return;
                    }
                
                    this.invalid = true;
                
                    this.cascade.forEach(
                        /**
                        * @param {!Tag} tag
                        */
                        function(tag)
                        {
                            tag.invalidate();
                        }
                    );
                }
                
                /**
                * Pair this tag with given tag
                *
                * @param {!Tag} tag
                */
                Tag.prototype.pairWith = function(tag)
                {
                    if (this.name === tag.name)
                    {
                        if (this.type === Tag.START_TAG
                         && tag.type  === Tag.END_TAG
                         && tag.pos   >=  this.pos)
                        {
                            this.endTag  = tag;
                            tag.startTag = this;
                
                            this.cascadeInvalidationTo(tag);
                        }
                        else if (this.type === Tag.END_TAG
                              && tag.type  === Tag.START_TAG
                              && tag.pos   <=  this.pos)
                        {
                            this.startTag = tag;
                            tag.endTag    = this;
                        }
                    }
                }
                
                /**
                * Remove a set of flags from this tag's
                *
                * @param {!number} flags
                */
                Tag.prototype.removeFlags = function(flags)
                {
                    this.flags &= ~flags;
                };
                
                /**
                * Set the bitfield of boolean rules that apply to this tag
                *
                * @param  {!number} flags Bitfield of boolean rules that apply to this tag
                */
                Tag.prototype.setFlags = function(flags)
                {
                    this.flags = flags;
                }
                
                /**
                * Set this tag's tiebreaker
                *
                * @param  {!number} sortPriority
                */
                Tag.prototype.setSortPriority = function(sortPriority)
                {
                    this.sortPriority = sortPriority;
                }
                
                //==========================================================================
                // Getters
                //==========================================================================
                
                /**
                * Return this tag's attributes
                *
                * @return {!Object}
                */
                Tag.prototype.getAttributes = function()
                {
                    var attributes = {};
                    for (var attrName in this.attributes)
                    {
                        attributes[attrName] = this.attributes[attrName];
                    }
                
                    return attributes;
                }
                
                /**
                * Return this tag's end tag
                *
                * @return {Tag} This tag's end tag
                */
                Tag.prototype.getEndTag = function()
                {
                    return this.endTag;
                }
                
                /**
                * Return the bitfield of boolean rules that apply to this tag
                *
                * @return {!number}
                */
                Tag.prototype.getFlags = function()
                {
                    return this.flags;
                }
                
                /**
                * Return the length of text consumed by this tag
                *
                * @return {!number}
                */
                Tag.prototype.getLen = function()
                {
                    return this.len;
                }
                
                /**
                * Return this tag's name
                *
                * @return {!string}
                */
                Tag.prototype.getName = function()
                {
                    return this.name;
                }
                
                /**
                * Return this tag's position
                *
                * @return {!number}
                */
                Tag.prototype.getPos = function()
                {
                    return this.pos;
                }
                
                /**
                * Return this tag's tiebreaker
                *
                * @return {!number}
                */
                Tag.prototype.getSortPriority = function()
                {
                    return this.sortPriority;
                }
                
                /**
                * Return this tag's start tag
                *
                * @return {Tag} This tag's start tag
                */
                Tag.prototype.getStartTag = function()
                {
                    return this.startTag;
                }
                
                /**
                * Return this tag's type
                *
                * @return {!number}
                */
                Tag.prototype.getType = function()
                {
                    return this.type;
                }
                
                //==========================================================================
                // Tag's status
                //==========================================================================
                
                /**
                * Test whether this tag can close given start tag
                *
                * @param  {!Tag} startTag
                * @return {!boolean}
                */
                Tag.prototype.canClose = function(startTag)
                {
                    if (this.invalid
                     || this.name !== startTag.name
                     || startTag.type !== Tag.START_TAG
                     || this.type !== Tag.END_TAG
                     || this.pos < startTag.pos
                     || (this.startTag && this.startTag !== startTag)
                     || (startTag.endTag && startTag.endTag !== this))
                    {
                        return false;
                    }
                
                    return true;
                }
                
                /**
                * Test whether this tag is a br tag
                *
                * @return {!boolean}
                */
                Tag.prototype.isBrTag = function()
                {
                    return (this.name === 'br');
                }
                
                /**
                * Test whether this tag is an end tag (self-closing tags inclusive)
                *
                * @return {!boolean}
                */
                Tag.prototype.isEndTag = function()
                {
                    return !!(this.type & Tag.END_TAG);
                }
                
                /**
                * Test whether this tag is an ignore tag
                *
                * @return {!boolean}
                */
                Tag.prototype.isIgnoreTag = function()
                {
                    return (this.name === 'i');
                }
                
                /**
                * Test whether this tag is invalid
                *
                * @return {!boolean}
                */
                Tag.prototype.isInvalid = function()
                {
                    return this.invalid;
                }
                
                /**
                * Test whether this tag represents a paragraph break
                *
                * @return {!boolean}
                */
                Tag.prototype.isParagraphBreak = function()
                {
                    return (this.name === 'pb');
                }
                
                /**
                * Test whether this tag is a self-closing tag
                *
                * @return {!boolean}
                */
                Tag.prototype.isSelfClosingTag = function()
                {
                    return (this.type === Tag.SELF_CLOSING_TAG);
                }
                
                /**
                * Test whether this tag is a special tag: "br", "i", "pb" or "v"
                *
                * @return {!boolean}
                */
                Tag.prototype.isSystemTag = function()
                {
                    return ('br i pb v'.indexOf(this.name) > -1);
                }
                
                /**
                * Test whether this tag is a start tag (self-closing tags inclusive)
                *
                * @return {!boolean}
                */
                Tag.prototype.isStartTag = function()
                {
                    return !!(this.type & Tag.START_TAG);
                }
                
                /**
                * Test whether this tag represents verbatim text
                *
                * @return {!boolean}
                */
                Tag.prototype.isVerbatim = function()
                {
                    return (this.name === 'v');
                }
                
                //==========================================================================
                // Attributes handling
                //==========================================================================
                
                /**
                * Return the value of given attribute
                *
                * @param  {!string} attrName
                * @return {!string}
                */
                Tag.prototype.getAttribute = function(attrName)
                {
                    return this.attributes[attrName];
                }
                
                /**
                * Return whether given attribute is set
                *
                * @param  {!string} attrName
                * @return {!boolean}
                */
                Tag.prototype.hasAttribute = function(attrName)
                {
                    return (attrName in this.attributes);
                }
                
                /**
                * Remove given attribute
                *
                * @param {!string} attrName
                */
                Tag.prototype.removeAttribute = function(attrName)
                {
                    delete this.attributes[attrName];
                }
                
                /**
                * Set the value of an attribute
                *
                * @param {!string} attrName  Attribute's name
                * @param {*}       attrValue Attribute's value
                */
                Tag.prototype.setAttribute = function(attrName, attrValue)
                {
                    this.attributes[attrName] = attrValue;
                }
                
                /**
                * Set all of this tag's attributes at once
                *
                * @param {!Object} attributes
                */
                Tag.prototype.setAttributes = function(attributes)
                {
                    this.attributes = {}
                
                    for (var attrName in attributes)
                    {
                        this.attributes[attrName] = attributes[attrName];
                    }
                }
                /**#@+
                * Boolean rules bitfield
                */
                /** @const */ var RULE_AUTO_CLOSE        = 1 << 0;
                /** @const */ var RULE_AUTO_REOPEN       = 1 << 1;
                /** @const */ var RULE_BREAK_PARAGRAPH   = 1 << 2;
                /** @const */ var RULE_CREATE_PARAGRAPHS = 1 << 3;
                /** @const */ var RULE_DISABLE_AUTO_BR   = 1 << 4;
                /** @const */ var RULE_ENABLE_AUTO_BR    = 1 << 5;
                /** @const */ var RULE_IGNORE_TAGS       = 1 << 6;
                /** @const */ var RULE_IGNORE_TEXT       = 1 << 7;
                /** @const */ var RULE_IGNORE_WHITESPACE = 1 << 8;
                /** @const */ var RULE_IS_TRANSPARENT    = 1 << 9;
                /** @const */ var RULE_PREVENT_BR        = 1 << 10;
                /** @const */ var RULE_SUSPEND_AUTO_BR   = 1 << 11;
                /** @const */ var RULE_TRIM_FIRST_LINE   = 1 << 12;
                /**#@-*/
                
                /**
                * @const Bitwise disjunction of rules related to automatic line breaks
                */
                var RULES_AUTO_LINEBREAKS = RULE_DISABLE_AUTO_BR | RULE_ENABLE_AUTO_BR | RULE_SUSPEND_AUTO_BR;
                
                /**
                * @const Bitwise disjunction of rules that are inherited by subcontexts
                */
                var RULES_INHERITANCE = RULE_ENABLE_AUTO_BR;
                
                /**
                * @const All the characters that are considered whitespace
                */
                var WHITESPACE = " \n\t";
                
                /**
                * @type {!Object.<string,!number>} Number of open tags for each tag name
                */
                var cntOpen;
                
                /**
                * @type {!Object.<string,!number>} Number of times each tag has been used
                */
                var cntTotal;
                
                /**
                * @type {!Object} Current context
                */
                var context;
                
                /**
                * @type {!number} How hard the parser has worked on fixing bad markup so far
                */
                var currentFixingCost;
                
                /**
                * @type {Tag} Current tag being processed
                */
                var currentTag;
                
                /**
                * @type {!boolean} Whether the output contains "rich" tags, IOW any tag that is not <p> or <br/>
                */
                var isRich;
                
                /**
                * @type {!Logger} This parser's logger
                */
                var logger = new Logger;
                
                /**
                * @type {!number} How hard the parser should work on fixing bad markup
                */
                var maxFixingCost = 10000;
                
                /**
                * @type {!Object} Associative array of namespace prefixes in use in document (prefixes used as key)
                */
                var namespaces;
                
                /**
                * @type {!Array.<!Tag>} Stack of open tags (instances of Tag)
                */
                var openTags;
                
                /**
                * @type {!string} This parser's output
                */
                var output;
                
                /**
                * @type {!Object.<!Object>}
                */
                var plugins={"Autolink":{parser:/**
                                * @param {!string} text
                                * @param {!Array.<Array>} matches
                                */
                                function(text, matches)
                                {
                                    /** @const */
                                    var config={attrName:"url",tagName:"URL"};
                                    matches.forEach(function(m)
                {
                    // Linkify the trimmed URL
                    linkifyUrl(m[0][1], trimUrl(m[0][0]));
                });
                
                /**
                * Linkify given URL at given position
                *
                * @param {!number} tagPos URL's position in the text
                * @param {!string} url    URL
                */
                function linkifyUrl(tagPos, url)
                {
                    // Ensure that the anchor (scheme/www) is still there
                    if (!/^www\.|^[^:]+:/i.test(url))
                    {
                        return;
                    }
                
                    // Create a zero-width end tag right after the URL
                    var endTag = addEndTag(config.tagName, tagPos + url.length, 0);
                
                    // If the URL starts with "www." we prepend "http://"
                    if (url[3] === '.')
                    {
                        url = 'http://' + url;
                    }
                
                    // Create a zero-width start tag right before the URL, with a slightly worse priority to
                    // allow specialized plugins to use the URL instead
                    var startTag = addStartTag(config.tagName, tagPos, 0, 1);
                    startTag.setAttribute(config.attrName, url);
                
                    // Pair the tags together
                    startTag.pairWith(endTag);
                };
                
                /**
                * Remove trailing punctuation from given URL
                *
                * We remove most ASCII non-letters from the end of the string.
                * Exceptions:
                *  - dashes (some YouTube URLs end with a dash due to the video ID)
                *  - equal signs (because of "foo?bar="),
                *  - trailing slashes,
                *  - closing parentheses are balanced separately.
                *
                * @param  {!string} url Original URL
                * @return {!string}     Trimmed URL
                */
                function trimUrl(url)
                {
                    return url.replace(/(?![-=\/)])[\s!-.:-@[-`{-~]+$/, '');
                }
                                },quickMatch:":\/\/",regexp:/\bhttps?:\/\/\S(?:[^\s()\[\]\uFF01-\uFF0F\uFF1A-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65]|\([^\s()]*\)|\[\w*\])+/ig,regexpLimit:50000},"BBCodes":{parser:/**
                                * @param {!string} text
                                * @param {!Array.<Array>} matches
                                */
                                function(text, matches)
                                {
                                    /** @const */
                                    var config={bbcodes:{"*":{tagName:"LI"},"ALIGN":[],"B":[],"CODE":{defaultAttribute:"lang"},"COLOR":[],"EM":[],"FONT":[],"I":[],"IMG":{contentAttributes:["src"],defaultAttribute:"src"},"LIST":{defaultAttribute:"type"},"MEDIA":{contentAttributes:["url"]},"QUOTE":{defaultAttribute:"author"},"S":[],"SIZE":[],"U":[],"URL":{contentAttributes:["url"]}}};
                                    /**
                * @type {!Object} Attributes of the BBCode being parsed
                */
                var attributes;
                
                /**
                * @type {!Object} Configuration for the BBCode being parsed
                */
                var bbcodeConfig;
                
                /**
                * @type {!string} Name of the BBCode being parsed
                */
                var bbcodeName;
                
                /**
                * @type {!string} Suffix of the BBCode being parsed, including its colon
                */
                var bbcodeSuffix;
                
                /**
                * @type {!number} Position of the cursor in the original text
                */
                var pos;
                
                /**
                * @type {!number} Position of the start of the BBCode being parsed
                */
                var startPos;
                
                /**
                * @type {!number} Length of the text being parsed
                */
                var textLen = text.length;
                
                /**
                * @type {!string} Text being parsed, normalized to uppercase
                */
                var uppercaseText = '';
                
                matches.forEach(function(m)
                {
                    bbcodeName = m[1][0].toUpperCase();
                    if (!(bbcodeName in config.bbcodes))
                    {
                        return;
                    }
                    bbcodeConfig = config.bbcodes[bbcodeName];
                    startPos     = m[0][1];
                    pos          = startPos + m[0][0].length;
                
                    try
                    {
                        parseBBCode();
                    }
                    catch (e)
                    {
                        // Do nothing
                    }
                });
                
                /**
                * Add the end tag that matches current BBCode
                *
                * @return {!Tag}
                */
                function addBBCodeEndTag()
                {
                    return addEndTag(getTagName(), startPos, pos - startPos);
                }
                
                /**
                * Add the self-closing tag that matches current BBCode
                *
                * @return {!Tag}
                */
                function addBBCodeSelfClosingTag()
                {
                    var tag = addSelfClosingTag(getTagName(), startPos, pos - startPos);
                    tag.setAttributes(attributes);
                
                    return tag;
                }
                
                /**
                * Add the start tag that matches current BBCode
                *
                * @return {!Tag}
                */
                function addBBCodeStartTag()
                {
                    var tag = addStartTag(getTagName(), startPos, pos - startPos);
                    tag.setAttributes(attributes);
                
                    return tag;
                }
                
                /**
                * Parse the end tag that matches given BBCode name and suffix starting at current position
                *
                * @return {Tag}
                */
                function captureEndTag()
                {
                    if (!uppercaseText)
                    {
                        uppercaseText = text.toUpperCase();
                    }
                    var match     = '[/' + bbcodeName + bbcodeSuffix + ']',
                        endTagPos = uppercaseText.indexOf(match, pos);
                    if (endTagPos < 0)
                    {
                        return null;
                    }
                
                    return addEndTag(getTagName(), endTagPos, match.length);
                }
                
                /**
                * Get the tag name for current BBCode
                *
                * @return string
                */
                function getTagName()
                {
                    // Use the configured tagName if available, or reuse the BBCode's name otherwise
                    return bbcodeConfig.tagName || bbcodeName;
                }
                
                /**
                * Parse attributes starting at current position
                *
                * @return array Associative array of [name => value]
                */
                function parseAttributes()
                {
                    var firstPos = pos, attrName;
                    attributes = {};
                    while (pos < textLen)
                    {
                        var c = text[pos];
                        if (" \n\t".indexOf(c) > -1)
                        {
                            ++pos;
                            continue;
                        }
                        if ('/]'.indexOf(c) > -1)
                        {
                            return;
                        }
                
                        // Capture the attribute name
                        var spn = /^[-\w]*/.exec(text.substr(pos, 100))[0].length;
                        if (spn)
                        {
                            attrName = text.substr(pos, spn).toLowerCase();
                            pos += spn;
                            if (pos >= textLen)
                            {
                                // The attribute name extends to the end of the text
                                throw '';
                            }
                            if (text[pos] !== '=')
                            {
                                // It's an attribute name not followed by an equal sign, ignore it
                                continue;
                            }
                        }
                        else if (c === '=' && pos === firstPos)
                        {
                            // This is the default param, e.g. [quote=foo]
                            attrName = bbcodeConfig.defaultAttribute || bbcodeName.toLowerCase();
                        }
                        else
                        {
                            throw '';
                        }
                
                        // Move past the = and make sure we're not at the end of the text
                        if (++pos >= textLen)
                        {
                            throw '';
                        }
                
                        attributes[attrName] = parseAttributeValue();
                    }
                }
                
                /**
                * Parse the attribute value starting at current position
                *
                * @return string
                */
                function parseAttributeValue()
                {
                    // Test whether the value is in quotes
                    if (text[pos] === '"' || text[pos] === "'")
                    {
                        return parseQuotedAttributeValue();
                    }
                
                    // Capture everything up to whichever comes first:
                    //  - an endline
                    //  - whitespace followed by a slash and a closing bracket
                    //  - a closing bracket, optionally preceded by whitespace
                    //  - whitespace followed by another attribute (name followed by equal sign)
                    //
                    // NOTE: this is for compatibility with some forums (such as vBulletin it seems)
                    //       that do not put attribute values in quotes, e.g.
                    //       [quote=John Smith;123456] (quoting "John Smith" from post #123456)
                    var match = /[^\]\n]*?(?=\s*(?:\s\/)?\]|\s+[-\w]+=)/.exec(text.substr(pos));
                    if (!match)
                    {
                        throw '';
                    }
                
                    var attrValue = match[0];
                    pos += attrValue.length;
                
                    return attrValue;
                }
                
                /**
                * Parse current BBCode
                *
                * @return void
                */
                function parseBBCode()
                {
                    parseBBCodeSuffix();
                
                    // Test whether this is an end tag
                    if (text[startPos + 1] === '/')
                    {
                        // Test whether the tag is properly closed and whether this tag has an identifier.
                        // We skip end tags that carry an identifier because they're automatically added
                        // when their start tag is processed
                        if (text[pos] === ']' && bbcodeSuffix === '')
                        {
                            ++pos;
                            addBBCodeEndTag();
                        }
                
                        return;
                    }
                
                    // Parse attributes and fill in the blanks with predefined attributes
                    parseAttributes();
                    if (bbcodeConfig.predefinedAttributes)
                    {
                        for (var attrName in bbcodeConfig.predefinedAttributes)
                        {
                            if (!(attrName in attributes))
                            {
                                attributes[attrName] = bbcodeConfig.predefinedAttributes[attrName];
                            }
                        }
                    }
                
                    // Test whether the tag is properly closed
                    if (text[pos] === ']')
                    {
                        ++pos;
                    }
                    else
                    {
                        // Test whether this is a self-closing tag
                        if (text.substr(pos, 2) === '/]')
                        {
                            pos += 2;
                            addBBCodeSelfClosingTag();
                        }
                
                        return;
                    }
                
                    // Record the names of attributes that need the content of this tag
                    var contentAttributes = [];
                    if (bbcodeConfig.contentAttributes)
                    {
                        bbcodeConfig.contentAttributes.forEach(function(attrName)
                        {
                            if (!(attrName in attributes))
                            {
                                contentAttributes.push(attrName);
                            }
                        });
                    }
                
                    // Look ahead and parse the end tag that matches this tag, if applicable
                    var requireEndTag = (bbcodeSuffix || bbcodeConfig.forceLookahead),
                        endTag = (requireEndTag || contentAttributes.length) ? captureEndTag() : null;
                    if (endTag)
                    {
                        contentAttributes.forEach(function(attrName)
                        {
                            attributes[attrName] = text.substr(pos, endTag.getPos() - pos);
                        });
                    }
                    else if (requireEndTag)
                    {
                        return;
                    }
                
                    // Create this start tag
                    var tag = addBBCodeStartTag();
                
                    // If an end tag was created, pair it with this start tag
                    if (endTag)
                    {
                        tag.pairWith(endTag);
                    }
                }
                
                /**
                * Parse the BBCode suffix starting at current position
                *
                * Used to explicitly pair specific tags together, e.g.
                *   [code:123][code]type your code here[/code][/code:123]
                *
                * @return void
                */
                function parseBBCodeSuffix()
                {
                    bbcodeSuffix = '';
                    if (text[pos] === ':')
                    {
                        // Capture the colon and the (0 or more) digits following it
                        bbcodeSuffix = /^:\d*/.exec(text.substr(pos))[0];
                
                        // Move past the suffix
                        pos += bbcodeSuffix.length;
                    }
                }
                
                /**
                * Parse a quoted attribute value that starts at current offset
                *
                * @return {!string}
                */
                function parseQuotedAttributeValue()
                {
                    var quote    = text[pos],
                        valuePos = pos + 1;
                    while (1)
                    {
                        // Look for the next quote
                        pos = text.indexOf(quote, pos + 1);
                        if (pos < 0)
                        {
                            // No matching quote. Apparently that string never ends...
                            throw '';
                        }
                
                        // Test for an odd number of backslashes before this character
                        var n = 0;
                        do
                        {
                            ++n;
                        }
                        while (text[pos - n] === '\\');
                
                        if (n % 2)
                        {
                            // If n is odd, it means there's an even number of backslashes. We can exit this loop
                            break;
                        }
                    }
                
                    // Unescape special characters ' " and \
                    var attrValue = text.substr(valuePos, pos - valuePos).replace(/\\([\\'"])/g, '$1');
                
                    // Skip past the closing quote
                    ++pos;
                
                    return attrValue;
                }
                                },quickMatch:"[",regexp:/\[\/?(\*|[-\w]+)(?=[\]\s=:\/])/g,regexpLimit:50000},"FancyPants":{parser:/**
                                * @param {!string} text
                                * @param {!Array.<Array>} matches
                                */
                                function(text, matches)
                                {
                                    /** @const */
                                    var config={attrName:"char",tagName:"FP"};
                                    var attrName       = config.attrName,
                    hasSingleQuote = (text.indexOf("'") >= 0),
                    hasDoubleQuote = (text.indexOf('"') >= 0),
                    tagName        = config.tagName;
                
                if (!config.disableQuotes)
                {
                    parseSingleQuotes();
                    parseSingleQuotePairs();
                    parseDoubleQuotePairs();
                }
                if (!config.disableGuillemets)
                {
                    parseGuillemets();
                }
                if (!config.disableMathSymbols)
                {
                    parseNotEqualSign();
                    parseSymbolsAfterDigits();
                    parseFractions();
                }
                if (!config.disablePunctuation)
                {
                    parseDashesAndEllipses();
                }
                if (!config.disableSymbols)
                {
                    parseSymbolsInParentheses();
                }
                
                /**
                * Add a fancy replacement tag
                *
                * @param  {!number} tagPos Position of the tag in the text
                * @param  {!number} tagLen Length of text consumed by the tag
                * @param  {!string} chr    Replacement character
                * @param  {number=} prio   Tag's priority
                * @return {!Tag}
                */
                function addTag(tagPos, tagLen, chr, prio)
                {
                    var tag = addSelfClosingTag(tagName, tagPos, tagLen, prio || 0);
                    tag.setAttribute(attrName, chr);
                
                    return tag;
                }
                
                /**
                * Parse dashes and ellipses
                *
                * Does en dash –, em dash — and ellipsis …
                */
                function parseDashesAndEllipses()
                {
                    if (text.indexOf('...') < 0 && text.indexOf('--') < 0)
                    {
                        return;
                    }
                
                    var chrs = {
                            '--'  : "\u2013",
                            '---' : "\u2014",
                            '...' : "\u2026"
                        },
                        regexp = /---?|\.\.\./g,
                        m;
                    while (m = regexp.exec(text))
                    {
                        addTag(+m['index'], m[0].length, chrs[m[0]]);
                    }
                }
                
                /**
                * Parse pairs of double quotes
                *
                * Does quote pairs “” -- must be done separately to handle nesting
                */
                function parseDoubleQuotePairs()
                {
                    if (hasDoubleQuote)
                    {
                        parseQuotePairs('"', /(?:^|\W)".+?"(?!\w)/g, "\u201c", "\u201d");
                    }
                }
                
                /**
                * Parse vulgar fractions
                */
                function parseFractions()
                {
                    if (text.indexOf('/') < 0)
                    {
                        return;
                    }
                
                    /** @const */
                    var map = {
                        '0/3'  : "\u2189",
                        '1/10' : "\u2152",
                        '1/2'  : "\u00BD",
                        '1/3'  : "\u2153",
                        '1/4'  : "\u00BC",
                        '1/5'  : "\u2155",
                        '1/6'  : "\u2159",
                        '1/7'  : "\u2150",
                        '1/8'  : "\u215B",
                        '1/9'  : "\u2151",
                        '2/3'  : "\u2154",
                        '2/5'  : "\u2156",
                        '3/4'  : "\u00BE",
                        '3/5'  : "\u2157",
                        '3/8'  : "\u215C",
                        '4/5'  : "\u2158",
                        '5/6'  : "\u215A",
                        '5/8'  : "\u215D",
                        '7/8'  : "\u215E"
                    };
                
                    var m, regexp = /\b(?:0\/3|1\/(?:[2-9]|10)|2\/[35]|3\/[458]|4\/5|5\/[68]|7\/8)\b/g;
                    while (m = regexp.exec(text))
                    {
                        addTag(+m['index'], m[0].length, map[m[0]]);
                    }
                }
                
                /**
                * Parse guillemets-style quotation marks
                */
                function parseGuillemets()
                {
                    if (text.indexOf('<<') < 0)
                    {
                        return;
                    }
                
                    var m, regexp = /<<( ?)(?! )[^\n<>]*?[^\n <>]\1>>(?!>)/g;
                    while (m = regexp.exec(text))
                    {
                        var left  = addTag(+m['index'],                   2, "\u00AB"),
                            right = addTag(+m['index'] + m[0].length - 2, 2, "\u00BB");
                
                        left.cascadeInvalidationTo(right);
                    }
                }
                
                /**
                * Parse the not equal sign
                *
                * Supports != and =/=
                */
                function parseNotEqualSign()
                {
                    if (text.indexOf('!=') < 0 && text.indexOf('=/=') < 0)
                    {
                        return;
                    }
                
                    var m, regexp = /\b (?:!|=\/)=(?= \b)/g;
                    while (m = regexp.exec(text))
                    {
                        addTag(+m['index'] + 1, m[0].length - 1, "\u2260");
                    }
                }
                
                /**
                * Parse pairs of quotes
                *
                * @param {!string} q          ASCII quote character 
                * @param {!RegExp} regexp     Regexp used to identify quote pairs
                * @param {!string} leftQuote  Fancy replacement for left quote
                * @param {!string} rightQuote Fancy replacement for right quote
                */
                function parseQuotePairs(q, regexp, leftQuote, rightQuote)
                {
                    var m;
                    while (m = regexp.exec(text))
                    {
                        var left  = addTag(+m['index'] + m[0].indexOf(q), 1, leftQuote),
                            right = addTag(+m['index'] + m[0].length - 1, 1, rightQuote);
                
                        // Cascade left tag's invalidation to the right so that if we skip the left quote,
                        // the right quote remains untouched
                        left.cascadeInvalidationTo(right);
                    }
                }
                
                /**
                * Parse pairs of single quotes
                *
                * Does quote pairs ‘’ must be done separately to handle nesting
                */
                function parseSingleQuotePairs()
                {
                    if (hasSingleQuote)
                    {
                        parseQuotePairs("'", /(?:^|\W)'.+?'(?!\w)/g, "\u2018", "\u2019");
                    }
                }
                
                /**
                * Parse single quotes in general
                *
                * Does apostrophes ’ after a letter or at the beginning of a word or a couple of digits
                */
                function parseSingleQuotes()
                {
                    if (!hasSingleQuote)
                    {
                        return;
                    }
                
                    var m, regexp = /[a-z]'|(?:^|\s)'(?=[a-z]|[0-9]{2})/gi;
                    while (m = regexp.exec(text))
                    {
                        // Give this tag a worse priority than default so that quote pairs take precedence
                        addTag(+m['index'] + m[0].indexOf("'"), 1, "\u2019", 10);
                    }
                }
                
                /**
                * Parse symbols found after digits
                *
                * Does symbols found after a digit:
                *  - apostrophe ’ if it's followed by an "s" as in 80's
                *  - prime ′ and double prime ″
                *  - multiply sign × if it's followed by an optional space and another digit
                */
                function parseSymbolsAfterDigits()
                {
                    if (!hasSingleQuote && !hasDoubleQuote && text.indexOf('x') < 0)
                    {
                        return;
                    }
                
                    /** @const */
                    var map = {
                        // 80's -- use an apostrophe
                        "'s" : "\u2019",
                        // 12' or 12" -- use a prime
                        "'"  : "\u2032",
                        "' " : "\u2032",
                        "'x" : "\u2032",
                        '"'  : "\u2033",
                        '" ' : "\u2033",
                        '"x' : "\u2033"
                    };
                
                    var m, regexp = /[0-9](?:'s|["']? ?x(?= ?[0-9])|["'])/g;
                    while (m = regexp.exec(text))
                    {
                        // Test for a multiply sign at the end
                        if (m[0][m[0].length - 1] === 'x')
                        {
                            addTag(+m['index'] + m[0].length - 1, 1, "\u00d7");
                        }
                
                        // Test for an apostrophe/prime right after the digit
                        var str = m[0].substr(1, 2);
                        if (map[str])
                        {
                            addTag(+m['index'] + 1, 1, map[str]);
                        }
                    }
                }
                
                /**
                * Parse symbols found in parentheses such as (c)
                *
                * Does symbols ©, ® and ™
                */
                function parseSymbolsInParentheses()
                {
                    if (text.indexOf('(') < 0)
                    {
                        return;
                    }
                
                    var chrs = {
                            '(c)'  : "\u00A9",
                            '(r)'  : "\u00AE",
                            '(tm)' : "\u2122"
                        },
                        regexp = /\((?:c|r|tm)\)/gi,
                        m;
                    while (m = regexp.exec(text))
                    {
                        addTag(+m['index'], m[0].length, chrs[m[0].toLowerCase()]);
                    }
                }
                                }},"HTMLEntities":{parser:/**
                                * @param {!string} text
                                * @param {!Array.<Array>} matches
                                */
                                function(text, matches)
                                {
                                    /** @const */
                                    var config={attrName:"char",tagName:"HE"};
                                    var tagName  = config.tagName,
                    attrName = config.attrName;
                
                matches.forEach(function(m)
                {
                    var entity = m[0][0],
                        chr    = html_entity_decode(entity);
                
                    if (chr === entity || chr.charCodeAt(0) < 32)
                    {
                        // If the entity was not decoded, we assume it's not valid and we ignore it.
                        // Same thing if it's a control character
                        return;
                    }
                
                    addSelfClosingTag(tagName, m[0][1], entity.length).setAttribute(attrName, chr);
                });
                                },quickMatch:"&",regexp:/&(?:[a-z]+|#(?:[0-9]+|x[0-9a-f]+));/ig,regexpLimit:50000},"MediaEmbed":{parser:/**
                                * @param {!string} text
                                * @param {!Array.<Array>} matches
                                */
                                function(text, matches)
                                {
                                    /** @const */
                                    var config={tagName:"MEDIA"};
                                    matches.forEach(function(m)
                {
                    var tagName = config.tagName,
                        url     = m[0][0],
                        pos     = m[0][1],
                        len     = url.length;
                
                    // Give that tag priority over other tags such as Autolink's
                    addSelfClosingTag(tagName, pos, len, -10).setAttribute('url', url);
                });
                                },quickMatch:":\/\/",regexp:/\bhttps?:\/\/[^["'\s]+/ig,regexpLimit:50000}};
                
                /**
                * @type {!number} Position of the cursor in the original text
                */
                var pos;
                
                /**
                * @type {!Object} Variables registered for use in filters
                */
                var registeredVars={"MediaEmbed.hosts":{"facebook.com":"facebook","gfycat.com":"gfycat","imgur.com":"imgur","reddit.com":"reddit","twitch.tv":"twitch","twitter.com":"twitter","vimeo.com":"vimeo","youtu.be":"youtube","youtube.com":"youtube"},"MediaEmbed.sites":{"facebook":[[[/\/(?!(?:apps|developers|graph)\.)[-\w.]*facebook\.com\/(?:[\/\w]+\/permalink|(?!pages\/|groups\/).*?)(?:\/|fbid=|\?v=)(\d+)(?=$|[\/?&#])/,o85888FAE],[/facebook\.com\/(\w+)\/(post|video)s?\//,["","user","type"]],[/facebook\.com\/video\/(post|video)\.php/,["","type"]]],[]],"gfycat":[[[/gfycat\.com\/(?!gaming|reactions|stickers|gifs\/tag)(?:gifs\/detail\/|ifr(?:ame)?\/)?(\w+)/,o85888FAE]],[{extract:[[/meta [^>]*="\w+:\w+:height" content="(\d+)/,["","height"]],[/meta [^>]*="\w+:\w+:width" content="(\d+)/,["","width"]]],match:[[/(?:)/,oB4E9AE58]],url:"https:\/\/gfycat.com\/ifr\/{@id}"}]],"imgur":[[[/imgur\.com\/(a\/\w+)/,o85888FAE],[/i\.imgur\.com\/(\w{5,7})[lms]?\./,o85888FAE],[/imgur\.com\/(\w+)(?![\w.\/])/,o85888FAE]],[{extract:[[/data-id="([\w\/]+)"/,o85888FAE]],match:[[/imgur\.com\/(?![art]\/|user\/)((?:gallery\/)?\w+)(?![\w.])/,["","path"]]],url:"https:\/\/api.imgur.com\/oembed.xml?url=\/{@path}"}]],"reddit":[[[/(\w+\/comments\/\w+(?:\/\w+\/\w+)?)/,o85888FAE]],[]],"twitch":[[[/twitch\.tv\/(?:videos|\w+\/v)\/(\d+)?/,["","video_id"]],[/www\.twitch\.tv\/(?!videos\/)(\w+)/,["","channel"]],[/t=((?:(?:\d+h)?\d+m)?\d+s)/,o90B2B224],[/clips\.twitch\.tv\/(?:(\w+)\/)?(\w+)/,["","channel","clip_id"]]],[]],"twitter":[[[/twitter\.com\/(?:#!\/|i\/)?\w+\/(?:status(?:es)?|tweet)\/(\d+)/,o85888FAE]],[]],"vimeo":[[[/vimeo\.com\/(?:channels\/[^\/]+\/|video\/)?(\d+)/,o85888FAE],[/#t=([\dhms]+)/,o90B2B224]],[]],"youtube":[[[/youtube\.com\/(?:watch.*?v=|v\/|attribution_link.*?v%3D)([-\w]+)/,o85888FAE],[/youtu\.be\/([-\w]+)/,o85888FAE],[/[#&?]t=(\d[\dhms]*)/,o90B2B224],[/[&?]list=([-\w]+)/,["","list"]]],[{extract:[[/\/vi\/([-\w]+)/,o85888FAE]],match:[[/\/shared\?ci=/,oB4E9AE58]]}]]},"urlConfig":{allowedSchemes:/^https?$/i}};
                
                /**
                * @type {!Object} Root context, used at the root of the document
                */
                var rootContext={allowed:oF6AF222C,flags:32};
                
                /**
                * @type {!Object} Tags' config
                * @const
                */
                var tagsConfig={"ALIGN":{allowed:oF6AF222C,attributes:{"align":{filterChain:[/**
                * @param {*} attrValue
                * @param {!string} attrName
                */
                function(attrValue,attrName){return RegexpFilter.filter(attrValue,/^(?:center|justify|left|right)$/i);}],required:!0}},bitNumber:5,filterChain:o1B3CF9D3,nestingLimit:10,rules:oEB3B7BEF,tagLimit:5000},"B":oAD0E5492,"CODE":{allowed:[0],attributes:{"lang":oC59E07AC},bitNumber:5,filterChain:o1B3CF9D3,nestingLimit:10,rules:{closeParent:oF4E3480F,flags:4432,fosterParent:oF4E3480F},tagLimit:5000},"COLOR":{allowed:oDA7900A1,attributes:{"color":{filterChain:[/**
                * @param {*} attrValue
                * @param {!string} attrName
                */
                function(attrValue,attrName){return RegexpFilter.filter(attrValue,/^(?:#(?:(?:[0-9a-f]{3}){1,2}|(?:[0-9a-f]{4}){1,2})|rgb\(\d{1,3}, *\d{1,3}, *\d{1,3}\)|rgba\(\d{1,3}, *\d{1,3}, *\d{1,3}, *\d*(?:\.\d+)?\)|[a-z]+)$/i);}],required:!0}},bitNumber:6,filterChain:o1B3CF9D3,nestingLimit:10,rules:oB565876D,tagLimit:5000},"EM":oAD0E5492,"FACEBOOK":{allowed:oB14C3B08,attributes:{"id":o1BC3EAF4,"type":o1BC3EAF4,"user":o1BC3EAF4},bitNumber:3,filterChain:o1B3CF9D3,nestingLimit:10,rules:oA80287CC,tagLimit:5000},"FONT":{allowed:oDA7900A1,attributes:{"font":{filterChain:[/**
                * @param {*} attrValue
                * @param {!string} attrName
                */
                function(attrValue,attrName){return RegexpFilter.filter(attrValue,/^(?:'[- \w]+'|"[- \w]+"|[- \w]+)(?:, *(?:'[- \w]+'|"[- \w]+"|[- \w]+))*$/);}],required:!0}},bitNumber:6,filterChain:o1B3CF9D3,nestingLimit:10,rules:oB565876D,tagLimit:5000},"FP":o2E4CE47C,"GFYCAT":{allowed:oB14C3B08,attributes:{"height":{defaultValue:360,filterChain:o63C22C4F,required:!1},"id":o1BC3EAF4,"width":{defaultValue:640,filterChain:o63C22C4F,required:!1}},bitNumber:3,filterChain:o1B3CF9D3,nestingLimit:10,rules:oA80287CC,tagLimit:5000},"HE":o2E4CE47C,"I":oAD0E5492,"IMG":{allowed:o57F7F446,attributes:{"alt":o1BC3EAF4,"height":o730E3161,"src":o0F509AAD,"title":o1BC3EAF4,"width":o730E3161},bitNumber:6,filterChain:o1B3CF9D3,nestingLimit:10,rules:oA80287CC,tagLimit:5000},"IMGUR":oBFF5DAF4,"LI":{allowed:oF6AF222C,attributes:{},bitNumber:4,filterChain:o1B3CF9D3,nestingLimit:10,rules:{closeParent:{"B":1,"COLOR":1,"EM":1,"FONT":1,"I":1,"LI":1,"S":1,"SIZE":1,"U":1,"URL":1},flags:256,fosterParent:oF4E3480F},tagLimit:5000},"LIST":{allowed:[32532],attributes:{"start":o730E3161,"type":{filterChain:[/**
                * @param {*} attrValue
                * @param {!string} attrName
                */
                function(attrValue,attrName){return HashmapFilter.filter(attrValue,{"A":"upper-alpha","I":"upper-roman","a":"lower-alpha","i":"lower-roman","1":"decimal"},!1);},/**
                * @param {*} attrValue
                * @param {!string} attrName
                */
                function(attrValue,attrName){return RegexpFilter.filter(attrValue,/^[- +,.0-9A-Za-z_]+$/);}],required:!1}},bitNumber:5,filterChain:o1B3CF9D3,nestingLimit:10,rules:{closeParent:oF4E3480F,createChild:["LI"],flags:3456,fosterParent:oF4E3480F},tagLimit:5000},"MEDIA":{allowed:[32619],attributes:{},bitNumber:2,filterChain:[/**
                * @param {!Tag} tag
                * @param {!Object} tagConfig
                */
                function(tag,tagConfig){return (/**
                * @param {!Tag}    tag   The original tag
                * @param {!Object} hosts Map of [host => siteId]
                * @param {!Object} sites Map of [siteId => siteConfig]
                */
                function (tag, hosts, sites)
                {
                    /**
                    * Filter a MEDIA tag
                    *
                    * This will always invalidate the original tag, and possibly replace it with the tag that
                    * corresponds to the media site
                    *
                    * @param {!Tag}    tag   The original tag
                    * @param {!Object} hosts Map of [host => siteId]
                    * @param {!Object} sites Map of [siteId => siteConfig]
                    */
                    function filterTag(tag, hosts, sites)
                    {
                        // Always invalidate this tag
                        tag.invalidate();
                
                        if (tag.hasAttribute('url'))
                        {
                            var url    = tag.getAttribute('url'),
                                siteId = getSiteIdFromUrl(url, hosts);
                            if (sites[siteId])
                            {
                                var attributes = getAttributes(url, sites[siteId]);
                                if (!empty(attributes))
                                {
                                    createTag(siteId.toUpperCase(), tag).setAttributes(attributes);
                                }
                            }
                        }
                    }
                
                    /**
                    * Add named captures from a set of regular expressions to a set of attributes
                    *
                    * @param  {!Object} attributes Associative array of strings
                    * @param  {string}  string     Text to match
                    * @param  {!Array}  regexps    List of [regexp, map] pairs
                    * @return {boolean}            Whether any regexp matched
                    */
                    function addNamedCaptures(attributes, string, regexps)
                    {
                        var matched = false;
                        regexps.forEach(function(pair)
                        {
                            var regexp = pair[0],
                                map    = pair[1],
                                m      = regexp.exec(string);
                            if (!m)
                            {
                                return;
                            }
                
                            matched = true;
                            map.forEach(function(name, i)
                            {
                                if (m[i] > '' && name > '')
                                {
                                    attributes[name] = m[i];
                                }
                            });
                        });
                
                        return matched;
                    }
                
                    /**
                    * Create a tag for a media embed
                    *
                    * @param  {string} tagName  Tag's name
                    * @param  {!Tag}   tag      Reference tag
                    * @return {!Tag}            New tag
                    */
                    function createTag(tagName, tag)
                    {
                        var startPos = tag.getPos(),
                            endTag   = tag.getEndTag(),
                            startLen,
                            endPos,
                            endLen;
                        if (endTag)
                        {
                            startLen = tag.getLen();
                            endPos   = endTag.getPos();
                            endLen   = endTag.getLen();
                        }
                        else
                        {
                            startLen = 0;
                            endPos   = tag.getPos() + tag.getLen();
                            endLen   = 0;
                        }
                
                        return addTagPair(tagName, startPos, startLen, endPos, endLen, tag.getSortPriority());
                    }
                
                    /**
                    * @param  {!Object} attributes
                    * @return {boolean}
                    */
                    function empty(attributes)
                    {
                        for (var attrName in attributes)
                        {
                            return false;
                        }
                
                        return true;
                    }
                
                    /**
                    * Return a set of attributes for given URL based on a site's config
                    *
                    * @param  {string}  url    Original URL
                    * @param  {!Object} config Site config
                    * @return {!Object}        Attributes
                    */
                    function getAttributes(url, config)
                    {
                        var attributes = {};
                        addNamedCaptures(attributes, url, config[0]);
                
                        return attributes;
                    }
                
                    /**
                    * Return the siteId that corresponds to given URL
                    *
                    * @param  {string} url   Original URL
                    * @param  {!Array} hosts Map of [hostname => siteId]
                    * @return {string}       URL's siteId, or an empty string
                    */
                    function getSiteIdFromUrl(url, hosts)
                    {
                        var m    = /^https?:\/\/([^\/]+)/.exec(url.toLowerCase()),
                            host = m[1] || '';
                        while (host > '')
                        {
                            if (hosts[host])
                            {
                                return hosts[host];
                            }
                            host = host.replace(/^[^.]*./, '');
                        }
                
                        return '';
                    }
                
                    filterTag(tag, hosts, sites);
                })(tag,registeredVars["MediaEmbed.hosts"],registeredVars["MediaEmbed.sites"],registeredVars["cacheDir"]);}],nestingLimit:10,rules:{flags:513},tagLimit:5000},"QUOTE":{allowed:oF6AF222C,attributes:{"author":o1BC3EAF4},bitNumber:5,filterChain:o1B3CF9D3,nestingLimit:10,rules:oEB3B7BEF,tagLimit:5000},"REDDIT":oBFF5DAF4,"S":oAD0E5492,"SIZE":{allowed:oDA7900A1,attributes:{"size":{filterChain:[/**
                * @param {*} attrValue
                * @param {!string} attrName
                */
                function(attrValue,attrName){return NumericFilter.filterRange(attrValue,8,36,logger);}],required:!0}},bitNumber:6,filterChain:o1B3CF9D3,nestingLimit:10,rules:oB565876D,tagLimit:5000},"TWITCH":{allowed:oB14C3B08,attributes:{"channel":o1BC3EAF4,"clip_id":o1BC3EAF4,"t":o1BC3EAF4,"video_id":o1BC3EAF4},bitNumber:3,filterChain:o1B3CF9D3,nestingLimit:10,rules:oA80287CC,tagLimit:5000},"TWITTER":oBFF5DAF4,"U":oAD0E5492,"URL":{allowed:[30310],attributes:{"title":o1BC3EAF4,"url":o0F509AAD},bitNumber:0,filterChain:o1B3CF9D3,nestingLimit:10,rules:{flags:514},tagLimit:5000},"VIMEO":{allowed:oB14C3B08,attributes:{"id":o1BC3EAF4,"t":o73D8BCD7},bitNumber:3,filterChain:o1B3CF9D3,nestingLimit:10,rules:oA80287CC,tagLimit:5000},"YOUTUBE":{allowed:oB14C3B08,attributes:{"id":oC59E07AC,"list":o1BC3EAF4,"t":o73D8BCD7},bitNumber:3,filterChain:o1B3CF9D3,nestingLimit:10,rules:oA80287CC,tagLimit:5000}};
                
                /**
                * @type {!Array.<!Tag>} Tag storage
                */
                var tagStack;
                
                /**
                * @type {!boolean} Whether the tags in the stack are sorted
                */
                var tagStackIsSorted;
                
                /**
                * @type {!string} Text being parsed
                */
                var text;
                
                /**
                * @type {!number} Length of the text being parsed
                */
                var textLen;
                
                /**
                * @type {!number} Counter incremented everytime the parser is reset. Used to as a canary to detect
                *                 whether the parser was reset during execution
                */
                var uid = 0;
                
                /**
                * @type {!number} Position before which we output text verbatim, without paragraphs or linebreaks
                */
                var wsPos;
                
                //==========================================================================
                // Public API
                //==========================================================================
                
                /**
                * Disable a tag
                *
                * @param {!string} tagName Name of the tag
                */
                function disableTag(tagName)
                {
                    if (tagsConfig[tagName])
                    {
                        copyTagConfig(tagName).isDisabled = true;
                    }
                }
                
                /**
                * Enable a tag
                *
                * @param {!string} tagName Name of the tag
                */
                function enableTag(tagName)
                {
                    if (tagsConfig[tagName])
                    {
                        copyTagConfig(tagName).isDisabled = false;
                    }
                }
                
                /**
                * Get this parser's Logger instance
                *
                * @return {!Logger}
                */
                function getLogger()
                {
                    return logger;
                }
                
                /**
                * Parse a text
                *
                * @param  {!string} _text Text to parse
                * @return {!string}       XML representation
                */
                function parse(_text)
                {
                    // Reset the parser and save the uid
                    reset(_text);
                    var _uid = uid;
                
                    // Do the heavy lifting
                    executePluginParsers();
                    processTags();
                
                    // Finalize the document
                    finalizeOutput();
                
                    // Check the uid in case a plugin or a filter reset the parser mid-execution
                    if (uid !== _uid)
                    {
                        throw 'The parser has been reset during execution';
                    }
                
                    // Log a warning if the fixing cost limit was exceeded
                    if (currentFixingCost > maxFixingCost)
                    {
                        logger.warn('Fixing cost limit exceeded');
                    }
                
                    return output;
                }
                
                /**
                * Reset the parser for a new parsing
                *
                * @param {!string} _text Text to be parsed
                */
                function reset(_text)
                {
                    // Normalize CR/CRLF to LF, remove control characters that aren't allowed in XML
                    _text = _text.replace(/\r\n?/g, "\n");
                    _text = _text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F]+/g, '');
                
                    // Clear the logs
                    logger.clear();
                
                    // Initialize the rest
                    cntOpen           = {};
                    cntTotal          = {};
                    currentFixingCost = 0;
                    currentTag        = null;
                    isRich            = false;
                    namespaces        = {};
                    openTags          = [];
                    output            = '';
                    pos               = 0;
                    tagStack          = [];
                    tagStackIsSorted  = false;
                    text              = _text;
                    textLen           = text.length;
                    wsPos             = 0;
                
                    // Initialize the root context
                    context = rootContext;
                    context.inParagraph = false;
                
                    // Bump the UID
                    ++uid;
                }
                
                /**
                * Change a tag's tagLimit
                *
                * NOTE: the default tagLimit should generally be set during configuration instead
                *
                * @param {!string} tagName  The tag's name, in UPPERCASE
                * @param {!number} tagLimit
                */
                function setTagLimit(tagName, tagLimit)
                {
                    if (tagsConfig[tagName])
                    {
                        copyTagConfig(tagName).tagLimit = tagLimit;
                    }
                }
                
                /**
                * Change a tag's nestingLimit
                *
                * NOTE: the default nestingLimit should generally be set during configuration instead
                *
                * @param {!string} tagName      The tag's name, in UPPERCASE
                * @param {!number} nestingLimit
                */
                function setNestingLimit(tagName, nestingLimit)
                {
                    if (tagsConfig[tagName])
                    {
                        copyTagConfig(tagName).nestingLimit = nestingLimit;
                    }
                }
                
                /**
                * Copy a tag's config
                *
                * This method ensures that the tag's config is its own object and not shared with another
                * identical tag
                *
                * @param  {!string} tagName Tag's name
                * @return {!Object}         Tag's config
                */
                function copyTagConfig(tagName)
                {
                    var tagConfig = {}, k;
                    for (k in tagsConfig[tagName])
                    {
                        tagConfig[k] = tagsConfig[tagName][k];
                    }
                
                    return tagsConfig[tagName] = tagConfig;
                }
                
                //==========================================================================
                // Output handling
                //==========================================================================
                
                /**
                * Replace Unicode characters outside the BMP with XML entities in the output
                */
                function encodeUnicodeSupplementaryCharacters()
                {
                    output = output.replace(
                        /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                        encodeUnicodeSupplementaryCharactersCallback
                    );
                }
                
                /**
                * Encode given surrogate pair into an XML entity
                *
                * @param  {!string} pair Surrogate pair
                * @return {!string}      XML entity
                */
                function encodeUnicodeSupplementaryCharactersCallback(pair)
                {
                    var cp = (pair.charCodeAt(0) << 10) + pair.charCodeAt(1) - 56613888;
                
                    return '&#' + cp + ';';
                }
                
                /**
                * Finalize the output by appending the rest of the unprocessed text and create the root node
                */
                function finalizeOutput()
                {
                    var tmp;
                
                    // Output the rest of the text and close the last paragraph
                    outputText(textLen, 0, true);
                
                    // Remove empty tag pairs, e.g. <I><U></U></I> as well as empty paragraphs
                    do
                    {
                        tmp = output;
                        output = output.replace(/<([^ />]+)[^>]*><\/\1>/g, '');
                    }
                    while (output !== tmp);
                
                    // Merge consecutive <i> tags
                    output = output.replace(/<\/i><i>/g, '');
                
                    // Remove control characters from the output to ensure it's valid XML
                    output = output.replace(/[\x00-\x08\x0B-\x1F]/g, '');
                
                    // Encode Unicode characters that are outside of the BMP
                    encodeUnicodeSupplementaryCharacters();
                
                    // Use a <r> root if the text is rich, or <t> for plain text (including <p></p> and <br/>)
                    var tagName = (isRich) ? 'r' : 't';
                
                    // Prepare the root node with all the namespace declarations
                    tmp = '<' + tagName;
                    if (HINT.namespaces)
                    {
                        for (var prefix in namespaces)
                        {
                            tmp += ' xmlns:' + prefix + '="urn:s9e:TextFormatter:' + prefix + '"';
                        }
                    }
                
                    output = tmp + '>' + output + '</' + tagName + '>';
                }
                
                /**
                * Append a tag to the output
                *
                * @param {!Tag} tag Tag to append
                */
                function outputTag(tag)
                {
                    isRich = true;
                
                    var tagName    = tag.getName(),
                        tagPos     = tag.getPos(),
                        tagLen     = tag.getLen(),
                        tagFlags   = tag.getFlags(),
                        skipBefore = 0,
                        skipAfter  = 0;
                
                    if (HINT.RULE_IGNORE_WHITESPACE && (tagFlags & RULE_IGNORE_WHITESPACE))
                    {
                        skipBefore = 1;
                        skipAfter  = (tag.isEndTag()) ? 2 : 1;
                    }
                
                    // Current paragraph must end before the tag if:
                    //  - the tag is a start (or self-closing) tag and it breaks paragraphs, or
                    //  - the tag is an end tag (but not self-closing)
                    var closeParagraph = false;
                    if (tag.isStartTag())
                    {
                        if (HINT.RULE_BREAK_PARAGRAPH && (tagFlags & RULE_BREAK_PARAGRAPH))
                        {
                            closeParagraph = true;
                        }
                    }
                    else
                    {
                        closeParagraph = true;
                    }
                
                    // Let the cursor catch up with this tag's position
                    outputText(tagPos, skipBefore, closeParagraph);
                
                    // Capture the text consumed by the tag
                    var tagText = (tagLen)
                                ? htmlspecialchars_noquotes(text.substr(tagPos, tagLen))
                                : '';
                
                    // Output current tag
                    if (tag.isStartTag())
                    {
                        // Handle paragraphs before opening the tag
                        if (!HINT.RULE_BREAK_PARAGRAPH || !(tagFlags & RULE_BREAK_PARAGRAPH))
                        {
                            outputParagraphStart(tagPos);
                        }
                
                        // Record this tag's namespace, if applicable
                        if (HINT.namespaces)
                        {
                            var colonPos = tagName.indexOf(':');
                            if (colonPos > 0)
                            {
                                namespaces[tagName.substr(0, colonPos)] = 0;
                            }
                        }
                
                        // Open the start tag and add its attributes, but don't close the tag
                        output += '<' + tagName;
                
                        // We output the attributes in lexical order. Helps canonicalizing the output and could
                        // prove useful someday
                        var attributes = tag.getAttributes(),
                            attributeNames = [];
                        for (var attrName in attributes)
                        {
                            attributeNames.push(attrName);
                        }
                        attributeNames.sort(
                            function(a, b)
                            {
                                return (a > b) ? 1 : -1;
                            }
                        );
                        attributeNames.forEach(
                            function(attrName)
                            {
                                output += ' ' + attrName + '="' + htmlspecialchars_compat(attributes[attrName].toString()).replace(/\n/g, '&#10;') + '"';
                            }
                        );
                
                        if (tag.isSelfClosingTag())
                        {
                            if (tagLen)
                            {
                                output += '>' + tagText + '</' + tagName + '>';
                            }
                            else
                            {
                                output += '/>';
                            }
                        }
                        else if (tagLen)
                        {
                            output += '><s>' + tagText + '</s>';
                        }
                        else
                        {
                            output += '>';
                        }
                    }
                    else
                    {
                        if (tagLen)
                        {
                            output += '<e>' + tagText + '</e>';
                        }
                
                        output += '</' + tagName + '>';
                    }
                
                    // Move the cursor past the tag
                    pos = tagPos + tagLen;
                
                    // Skip newlines (no other whitespace) after this tag
                    wsPos = pos;
                    while (skipAfter && wsPos < textLen && text[wsPos] === "\n")
                    {
                        // Decrement the number of lines to skip
                        --skipAfter;
                
                        // Move the cursor past the newline
                        ++wsPos;
                    }
                }
                
                /**
                * Output the text between the cursor's position (included) and given position (not included)
                *
                * @param  {!number}  catchupPos     Position we're catching up to
                * @param  {!number}  maxLines       Maximum number of lines to ignore at the end of the text
                * @param  {!boolean} closeParagraph Whether to close the paragraph at the end, if applicable
                */
                function outputText(catchupPos, maxLines, closeParagraph)
                {
                    if (closeParagraph)
                    {
                        if (!(context.flags & RULE_CREATE_PARAGRAPHS))
                        {
                            closeParagraph = false;
                        }
                        else
                        {
                            // Ignore any number of lines at the end if we're closing a paragraph
                            maxLines = -1;
                        }
                    }
                
                    if (pos >= catchupPos)
                    {
                        // We're already there, close the paragraph if applicable and return
                        if (closeParagraph)
                        {
                            outputParagraphEnd();
                        }
                    }
                
                    // Skip over previously identified whitespace if applicable
                    if (wsPos > pos)
                    {
                        var skipPos = Math.min(catchupPos, wsPos);
                        output += text.substr(pos, skipPos - pos);
                        pos = skipPos;
                
                        if (pos >= catchupPos)
                        {
                            // Skipped everything. Close the paragraph if applicable and return
                            if (closeParagraph)
                            {
                                outputParagraphEnd();
                            }
                        }
                    }
                
                    var catchupLen, catchupText;
                
                    // Test whether we're even supposed to output anything
                    if (HINT.RULE_IGNORE_TEXT && context.flags & RULE_IGNORE_TEXT)
                    {
                        catchupLen  = catchupPos - pos,
                        catchupText = text.substr(pos, catchupLen);
                
                        // If the catchup text is not entirely composed of whitespace, we put it inside ignore tags
                        if (!/^[ \n\t]*$/.test(catchupText))
                        {
                            catchupText = '<i>' + htmlspecialchars_noquotes(catchupText) + '</i>';
                        }
                
                        output += catchupText;
                        pos = catchupPos;
                
                        if (closeParagraph)
                        {
                            outputParagraphEnd();
                        }
                
                        return;
                    }
                
                    // Compute the amount of text to ignore at the end of the output
                    var ignorePos = catchupPos,
                        ignoreLen = 0;
                
                    // Ignore as many lines (including whitespace) as specified
                    while (maxLines && --ignorePos >= pos)
                    {
                        var c = text[ignorePos];
                        if (c !== ' ' && c !== "\n" && c !== "\t")
                        {
                            break;
                        }
                
                        if (c === "\n")
                        {
                            --maxLines;
                        }
                
                        ++ignoreLen;
                    }
                
                    // Adjust catchupPos to ignore the text at the end
                    catchupPos -= ignoreLen;
                
                    // Break down the text in paragraphs if applicable
                    if (HINT.RULE_CREATE_PARAGRAPHS && context.flags & RULE_CREATE_PARAGRAPHS)
                    {
                        if (!context.inParagraph)
                        {
                            outputWhitespace(catchupPos);
                
                            if (catchupPos > pos)
                            {
                                outputParagraphStart(catchupPos);
                            }
                        }
                
                        // Look for a paragraph break in this text
                        var pbPos = text.indexOf("\n\n", pos);
                
                        while (pbPos > -1 && pbPos < catchupPos)
                        {
                            outputText(pbPos, 0, true);
                            outputParagraphStart(catchupPos);
                
                            pbPos = text.indexOf("\n\n", pos);
                        }
                    }
                
                    // Capture, escape and output the text
                    if (catchupPos > pos)
                    {
                        catchupText = htmlspecialchars_noquotes(
                            text.substr(pos, catchupPos - pos)
                        );
                
                        // Format line breaks if applicable
                        if (HINT.RULE_ENABLE_AUTO_BR && (context.flags & RULES_AUTO_LINEBREAKS) === RULE_ENABLE_AUTO_BR)
                        {
                            catchupText = catchupText.replace(/\n/g, "<br/>\n");
                        }
                
                        output += catchupText;
                    }
                
                    // Close the paragraph if applicable
                    if (closeParagraph)
                    {
                        outputParagraphEnd();
                    }
                
                    // Add the ignored text if applicable
                    if (ignoreLen)
                    {
                        output += text.substr(catchupPos, ignoreLen);
                    }
                
                    // Move the cursor past the text
                    pos = catchupPos + ignoreLen;
                }
                
                /**
                * Output a linebreak tag
                *
                * @param  {!Tag} tag
                * @return void
                */
                function outputBrTag(tag)
                {
                    outputText(tag.getPos(), 0, false);
                    output += '<br/>';
                }
                
                /**
                * Output an ignore tag
                *
                * @param  {!Tag} tag
                * @return void
                */
                function outputIgnoreTag(tag)
                {
                    var tagPos = tag.getPos(),
                        tagLen = tag.getLen();
                
                    // Capture the text to ignore
                    var ignoreText = text.substr(tagPos, tagLen);
                
                    // Catch up with the tag's position then output the tag
                    outputText(tagPos, 0, false);
                    output += '<i>' + htmlspecialchars_noquotes(ignoreText) + '</i>';
                    isRich = true;
                
                    // Move the cursor past this tag
                    pos = tagPos + tagLen;
                }
                
                /**
                * Start a paragraph between current position and given position, if applicable
                *
                * @param  {!number} maxPos Rightmost position at which the paragraph can be opened
                */
                function outputParagraphStart(maxPos)
                {
                    if (!HINT.RULE_CREATE_PARAGRAPHS)
                    {
                        return;
                    }
                
                    // Do nothing if we're already in a paragraph, or if we don't use paragraphs
                    if (context.inParagraph
                     || !(context.flags & RULE_CREATE_PARAGRAPHS))
                    {
                        return;
                    }
                
                    // Output the whitespace between pos and maxPos if applicable
                    outputWhitespace(maxPos);
                
                    // Open the paragraph, but only if it's not at the very end of the text
                    if (pos < textLen)
                    {
                        output += '<p>';
                        context.inParagraph = true;
                    }
                }
                
                /**
                * Close current paragraph at current position if applicable
                */
                function outputParagraphEnd()
                {
                    // Do nothing if we're not in a paragraph
                    if (!context.inParagraph)
                    {
                        return;
                    }
                
                    output += '</p>';
                    context.inParagraph = false;
                }
                
                /**
                * Output the content of a verbatim tag
                *
                * @param {!Tag} tag
                */
                function outputVerbatim(tag)
                {
                    var flags = context.flags;
                    context.flags = tag.getFlags();
                    outputText(currentTag.getPos() + currentTag.getLen(), 0, false);
                    context.flags = flags;
                }
                
                /**
                * Skip as much whitespace after current position as possible
                *
                * @param  {!number} maxPos Rightmost character to be skipped
                */
                function outputWhitespace(maxPos)
                {
                    while (pos < maxPos && " \n\t".indexOf(text[pos]) > -1)
                    {
                        output += text[pos];
                        ++pos;
                    }
                }
                
                //==========================================================================
                // Plugins handling
                //==========================================================================
                
                /**
                * Disable a plugin
                *
                * @param {!string} pluginName Name of the plugin
                */
                function disablePlugin(pluginName)
                {
                    if (plugins[pluginName])
                    {
                        plugins[pluginName].isDisabled = true;
                    }
                }
                
                /**
                * Enable a plugin
                *
                * @param {!string} pluginName Name of the plugin
                */
                function enablePlugin(pluginName)
                {
                    if (plugins[pluginName])
                    {
                        plugins[pluginName].isDisabled = false;
                    }
                }
                
                /**
                * Execute given plugin
                *
                * @param {!string} pluginName Plugin's name
                */
                function executePluginParser(pluginName)
                {
                    var pluginConfig = plugins[pluginName];
                    if (pluginConfig.quickMatch && text.indexOf(pluginConfig.quickMatch) < 0)
                    {
                        return;
                    }
                
                    var matches = [];
                    if (pluginConfig.regexp)
                    {
                        matches = getMatches(pluginConfig.regexp, pluginConfig.regexpLimit);
                        if (!matches.length)
                        {
                            return;
                        }
                    }
                
                    // Execute the plugin's parser, which will add tags via addStartTag() and others
                    getPluginParser(pluginName)(text, matches);
                }
                
                /**
                * Execute all the plugins
                */
                function executePluginParsers()
                {
                    for (var pluginName in plugins)
                    {
                        if (!plugins[pluginName].isDisabled)
                        {
                            executePluginParser(pluginName);
                        }
                    }
                }
                
                /**
                * Get regexp matches in a manner similar to preg_match_all() with PREG_SET_ORDER | PREG_OFFSET_CAPTURE
                *
                * @param  {!RegExp} regexp
                * @param  {!number} limit
                * @return {!Array.<!Array>}
                */
                function getMatches(regexp, limit)
                {
                    // Reset the regexp
                    regexp.lastIndex = 0;
                    var matches = [], cnt = 0, m;
                    while (++cnt <= limit && (m = regexp.exec(text)))
                    {
                        // NOTE: coercing m.index to a number because Closure Compiler thinks pos is a string otherwise
                        var pos   = +m['index'],
                            match = [[m[0], pos]],
                            i = 0;
                        while (++i < m.length)
                        {
                            var str = m[i];
                
                            // Sub-expressions that were not evaluated return undefined
                            if (str === undefined)
                            {
                                match.push(['', -1]);
                            }
                            else
                            {
                                match.push([str, text.indexOf(str, pos)]);
                                pos += str.length;
                            }
                        }
                
                        matches.push(match);
                    }
                
                    return matches;
                }
                
                /**
                * Get the callback for given plugin's parser
                *
                * @param  {!string}   pluginName
                * @return {!function(string, Array)}
                */
                function getPluginParser(pluginName)
                {
                    return plugins[pluginName].parser;
                }
                
                /**
                * Register a parser
                *
                * Can be used to add a new parser with no plugin config, or pre-generate a parser for an
                * existing plugin
                *
                * @param  {!string}   pluginName
                * @param  {!Function} parser
                * @param  {RegExp}   regexp
                * @param  {number}   limit
                */
                function registerParser(pluginName, parser, regexp, limit)
                {
                    // Create an empty config for this plugin to ensure it is executed
                    if (!plugins[pluginName])
                    {
                        plugins[pluginName] = {};
                    }
                    if (regexp)
                    {
                        plugins[pluginName].regexp = regexp;
                        plugins[pluginName].limit  = limit || Infinity;
                    }
                    plugins[pluginName].parser = parser;
                }
                
                //==========================================================================
                // Rules handling
                //==========================================================================
                
                /**
                * Apply closeAncestor rules associated with given tag
                *
                * @param  {!Tag}     tag Tag
                * @return {!boolean}     Whether a new tag has been added
                */
                function closeAncestor(tag)
                {
                    if (!HINT.closeAncestor)
                    {
                        return false;
                    }
                
                    if (openTags.length)
                    {
                        var tagName   = tag.getName(),
                            tagConfig = tagsConfig[tagName];
                
                        if (tagConfig.rules.closeAncestor)
                        {
                            var i = openTags.length;
                
                            while (--i >= 0)
                            {
                                var ancestor     = openTags[i],
                                    ancestorName = ancestor.getName();
                
                                if (tagConfig.rules.closeAncestor[ancestorName])
                                {
                                    ++currentFixingCost;
                
                                    // We have to close this ancestor. First we reinsert this tag...
                                    tagStack.push(tag);
                
                                    // ...then we add a new end tag for it with a better priority
                                    addMagicEndTag(ancestor, tag.getPos(), tag.getSortPriority() - 1);
                
                                    return true;
                                }
                            }
                        }
                    }
                
                    return false;
                }
                
                /**
                * Apply closeParent rules associated with given tag
                *
                * @param  {!Tag}     tag Tag
                * @return {!boolean}     Whether a new tag has been added
                */
                function closeParent(tag)
                {
                    if (!HINT.closeParent)
                    {
                        return false;
                    }
                
                    if (openTags.length)
                    {
                        var tagName   = tag.getName(),
                            tagConfig = tagsConfig[tagName];
                
                        if (tagConfig.rules.closeParent)
                        {
                            var parent     = openTags[openTags.length - 1],
                                parentName = parent.getName();
                
                            if (tagConfig.rules.closeParent[parentName])
                            {
                                ++currentFixingCost;
                
                                // We have to close that parent. First we reinsert the tag...
                                tagStack.push(tag);
                
                                // ...then we add a new end tag for it with a better priority
                                addMagicEndTag(parent, tag.getPos(), tag.getSortPriority() - 1);
                
                                return true;
                            }
                        }
                    }
                
                    return false;
                }
                
                /**
                * Apply the createChild rules associated with given tag
                *
                * @param {!Tag} tag Tag
                */
                function createChild(tag)
                {
                    if (!HINT.createChild)
                    {
                        return;
                    }
                
                    var tagConfig = tagsConfig[tag.getName()];
                    if (tagConfig.rules.createChild)
                    {
                        var priority = -1000,
                            _text    = text.substr(pos),
                            tagPos   = pos + _text.length - _text.replace(/^[ \n\r\t]+/, '').length;
                        tagConfig.rules.createChild.forEach(function(tagName)
                        {
                            addStartTag(tagName, tagPos, 0, ++priority);
                        });
                    }
                }
                
                /**
                * Apply fosterParent rules associated with given tag
                *
                * NOTE: this rule has the potential for creating an unbounded loop, either if a tag tries to
                *       foster itself or two or more tags try to foster each other in a loop. We mitigate the
                *       risk by preventing a tag from creating a child of itself (the parent still gets closed)
                *       and by checking and increasing the currentFixingCost so that a loop of multiple tags
                *       do not run indefinitely. The default tagLimit and nestingLimit also serve to prevent the
                *       loop from running indefinitely
                *
                * @param  {!Tag}     tag Tag
                * @return {!boolean}     Whether a new tag has been added
                */
                function fosterParent(tag)
                {
                    if (!HINT.fosterParent)
                    {
                        return false;
                    }
                
                    if (openTags.length)
                    {
                        var tagName   = tag.getName(),
                            tagConfig = tagsConfig[tagName];
                
                        if (tagConfig.rules.fosterParent)
                        {
                            var parent     = openTags[openTags.length - 1],
                                parentName = parent.getName();
                
                            if (tagConfig.rules.fosterParent[parentName])
                            {
                                if (parentName !== tagName && currentFixingCost < maxFixingCost)
                                {
                                    addFosterTag(tag, parent)
                                }
                
                                // Reinsert current tag
                                tagStack.push(tag);
                
                                // And finally close its parent with a priority that ensures it is processed
                                // before this tag
                                addMagicEndTag(parent, tag.getPos(), tag.getSortPriority() - 1);
                
                                // Adjust the fixing cost to account for the additional tags/processing
                                currentFixingCost += 4;
                
                                return true;
                            }
                        }
                    }
                
                    return false;
                }
                
                /**
                * Apply requireAncestor rules associated with given tag
                *
                * @param  {!Tag}     tag Tag
                * @return {!boolean}     Whether this tag has an unfulfilled requireAncestor requirement
                */
                function requireAncestor(tag)
                {
                    if (!HINT.requireAncestor)
                    {
                        return false;
                    }
                
                    var tagName   = tag.getName(),
                        tagConfig = tagsConfig[tagName];
                
                    if (tagConfig.rules.requireAncestor)
                    {
                        var i = tagConfig.rules.requireAncestor.length;
                        while (--i >= 0)
                        {
                            var ancestorName = tagConfig.rules.requireAncestor[i];
                            if (cntOpen[ancestorName])
                            {
                                return false;
                            }
                        }
                
                        logger.err('Tag requires an ancestor', {
                            'requireAncestor' : tagConfig.rules.requireAncestor.join(', '),
                            'tag'             : tag
                        });
                
                        return true;
                    }
                
                    return false;
                }
                
                //==========================================================================
                // Tag processing
                //==========================================================================
                
                /**
                * Create and add a copy of a tag as a child of a given tag
                *
                * @param {!Tag} tag       Current tag
                * @param {!Tag} fosterTag Tag to foster
                */
                function addFosterTag(tag, fosterTag)
                {
                    var coords    = getMagicStartCoords(tag.getPos() + tag.getLen()),
                        childPos  = coords[0],
                        childPrio = coords[1];
                
                    // Add a 0-width copy of the parent tag after this tag and make it depend on this tag
                    var childTag = addCopyTag(fosterTag, childPos, 0, childPrio);
                    tag.cascadeInvalidationTo(childTag);
                }
                
                /**
                * Create and add an end tag for given start tag at given position
                *
                * @param  {!Tag}    startTag Start tag
                * @param  {!number} tagPos   End tag's position (will be adjusted for whitespace if applicable)
                * @param  {number=} prio     End tag's priority
                * @return {!Tag}
                */
                function addMagicEndTag(startTag, tagPos, prio)
                {
                    var tagName = startTag.getName();
                
                    // Adjust the end tag's position if whitespace is to be minimized
                    if (HINT.RULE_IGNORE_WHITESPACE && ((currentTag.getFlags() | startTag.getFlags()) & RULE_IGNORE_WHITESPACE))
                    {
                        tagPos = getMagicEndPos(tagPos);
                    }
                
                    // Add a 0-width end tag that is paired with the given start tag
                    var endTag = addEndTag(tagName, tagPos, 0, prio || 0);
                    endTag.pairWith(startTag);
                
                    return endTag;
                }
                
                /**
                * Compute the position of a magic end tag, adjusted for whitespace
                *
                * @param  {!number} tagPos Rightmost possible position for the tag
                * @return {!number}
                */
                function getMagicEndPos(tagPos)
                {
                    // Back up from given position to the cursor's position until we find a character that
                    // is not whitespace
                    while (tagPos > pos && WHITESPACE.indexOf(text[tagPos - 1]) > -1)
                    {
                        --tagPos;
                    }
                
                    return tagPos;
                }
                
                /**
                * Compute the position and priority of a magic start tag, adjusted for whitespace
                *
                * @param  {!number} tagPos Leftmost possible position for the tag
                * @return {!Array}         [Tag pos, priority]
                */
                function getMagicStartCoords(tagPos)
                {
                    var nextPos, nextPrio, nextTag, prio;
                    if (!tagStack.length)
                    {
                        // Set the next position outside the text boundaries
                        nextPos  = textLen + 1;
                        nextPrio = 0;
                    }
                    else
                    {
                        nextTag  = tagStack[tagStack.length - 1];
                        nextPos  = nextTag.getPos();
                        nextPrio = nextTag.getSortPriority();
                    }
                
                    // Find the first non-whitespace position before next tag or the end of text
                    while (tagPos < nextPos && WHITESPACE.indexOf(text[tagPos]) > -1)
                    {
                        ++tagPos;
                    }
                
                    // Set a priority that ensures this tag appears before the next tag
                    prio = (tagPos === nextPos) ? nextPrio - 1 : 0;
                
                    return [tagPos, prio];
                }
                
                /**
                * Test whether given start tag is immediately followed by a closing tag
                *
                * @param  {!Tag} tag Start tag (including self-closing)
                * @return {!boolean}
                */
                function isFollowedByClosingTag(tag)
                {
                    return (!tagStack.length) ? false : tagStack[tagStack.length - 1].canClose(tag);
                }
                
                /**
                * Process all tags in the stack
                */
                function processTags()
                {
                    if (!tagStack.length)
                    {
                        return;
                    }
                
                    // Initialize the count tables
                    for (var tagName in tagsConfig)
                    {
                        cntOpen[tagName]  = 0;
                        cntTotal[tagName] = 0;
                    }
                
                    // Process the tag stack, close tags that were left open and repeat until done
                    do
                    {
                        while (tagStack.length)
                        {
                            if (!tagStackIsSorted)
                            {
                                sortTags();
                            }
                
                            currentTag = tagStack.pop();
                            processCurrentTag();
                        }
                
                        // Close tags that were left open
                        openTags.forEach(function (startTag)
                        {
                            // NOTE: we add tags in hierarchical order (ancestors to descendants) but since
                            //       the stack is processed in LIFO order, it means that tags get closed in
                            //       the correct order, from descendants to ancestors
                            addMagicEndTag(startTag, textLen);
                        });
                    }
                    while (tagStack.length);
                }
                
                /**
                * Process current tag
                */
                function processCurrentTag()
                {
                    // Invalidate current tag if tags are disabled and current tag would not close the last open
                    // tag and is not a system tag
                    if ((context.flags & RULE_IGNORE_TAGS)
                     && !currentTag.canClose(openTags[openTags.length - 1])
                     && !currentTag.isSystemTag())
                    {
                        currentTag.invalidate();
                    }
                
                    var tagPos = currentTag.getPos(),
                        tagLen = currentTag.getLen();
                
                    // Test whether the cursor passed this tag's position already
                    if (pos > tagPos && !currentTag.isInvalid())
                    {
                        // Test whether this tag is paired with a start tag and this tag is still open
                        var startTag = currentTag.getStartTag();
                
                        if (startTag && openTags.indexOf(startTag) >= 0)
                        {
                            // Create an end tag that matches current tag's start tag, which consumes as much of
                            // the same text as current tag and is paired with the same start tag
                            addEndTag(
                                startTag.getName(),
                                pos,
                                Math.max(0, tagPos + tagLen - pos)
                            ).pairWith(startTag);
                
                            // Note that current tag is not invalidated, it's merely replaced
                            return;
                        }
                
                        // If this is an ignore tag, try to ignore as much as the remaining text as possible
                        if (currentTag.isIgnoreTag())
                        {
                            var ignoreLen = tagPos + tagLen - pos;
                
                            if (ignoreLen > 0)
                            {
                                // Create a new ignore tag and move on
                                addIgnoreTag(pos, ignoreLen);
                
                                return;
                            }
                        }
                
                        // Skipped tags are invalidated
                        currentTag.invalidate();
                    }
                
                    if (currentTag.isInvalid())
                    {
                        return;
                    }
                
                    if (currentTag.isIgnoreTag())
                    {
                        outputIgnoreTag(currentTag);
                    }
                    else if (currentTag.isBrTag())
                    {
                        // Output the tag if it's allowed, ignore it otherwise
                        if (!HINT.RULE_PREVENT_BR || !(context.flags & RULE_PREVENT_BR))
                        {
                            outputBrTag(currentTag);
                        }
                    }
                    else if (currentTag.isParagraphBreak())
                    {
                        outputText(currentTag.getPos(), 0, true);
                    }
                    else if (currentTag.isVerbatim())
                    {
                        outputVerbatim(currentTag);
                    }
                    else if (currentTag.isStartTag())
                    {
                        processStartTag(currentTag);
                    }
                    else
                    {
                        processEndTag(currentTag);
                    }
                }
                
                /**
                * Process given start tag (including self-closing tags) at current position
                *
                * @param {!Tag} tag Start tag (including self-closing)
                */
                function processStartTag(tag)
                {
                    var tagName   = tag.getName(),
                        tagConfig = tagsConfig[tagName];
                
                    // 1. Check that this tag has not reached its global limit tagLimit
                    // 2. Execute this tag's filterChain, which will filter/validate its attributes
                    // 3. Apply closeParent, closeAncestor and fosterParent rules
                    // 4. Check for nestingLimit
                    // 5. Apply requireAncestor rules
                    //
                    // This order ensures that the tag is valid and within the set limits before we attempt to
                    // close parents or ancestors. We need to close ancestors before we can check for nesting
                    // limits, whether this tag is allowed within current context (the context may change
                    // as ancestors are closed) or whether the required ancestors are still there (they might
                    // have been closed by a rule.)
                    if (cntTotal[tagName] >= tagConfig.tagLimit)
                    {
                        logger.err(
                            'Tag limit exceeded',
                            {
                                'tag'      : tag,
                                'tagName'  : tagName,
                                'tagLimit' : tagConfig.tagLimit
                            }
                        );
                        tag.invalidate();
                
                        return;
                    }
                
                    filterTag(tag);
                    if (tag.isInvalid())
                    {
                        return;
                    }
                
                    if (currentFixingCost < maxFixingCost)
                    {
                        if (fosterParent(tag) || closeParent(tag) || closeAncestor(tag))
                        {
                            // This tag parent/ancestor needs to be closed, we just return (the tag is still valid)
                            return;
                        }
                    }
                
                    if (cntOpen[tagName] >= tagConfig.nestingLimit)
                    {
                        logger.err(
                            'Nesting limit exceeded',
                            {
                                'tag'          : tag,
                                'tagName'      : tagName,
                                'nestingLimit' : tagConfig.nestingLimit
                            }
                        );
                        tag.invalidate();
                
                        return;
                    }
                
                    if (!tagIsAllowed(tagName))
                    {
                        var msg     = 'Tag is not allowed in this context',
                            context = {'tag': tag, 'tagName': tagName};
                        if (tag.getLen() > 0)
                        {
                            logger.warn(msg, context);
                        }
                        else
                        {
                            logger.debug(msg, context);
                        }
                        tag.invalidate();
                
                        return;
                    }
                
                    if (requireAncestor(tag))
                    {
                        tag.invalidate();
                
                        return;
                    }
                
                    // If this tag has an autoClose rule and it's not paired with an end tag or followed by an
                    // end tag, we replace it with a self-closing tag with the same properties
                    if (HINT.RULE_AUTO_CLOSE
                     && tag.getFlags() & RULE_AUTO_CLOSE
                     && !tag.getEndTag()
                     && !isFollowedByClosingTag(tag))
                    {
                        var newTag = new Tag(Tag.SELF_CLOSING_TAG, tagName, tag.getPos(), tag.getLen());
                        newTag.setAttributes(tag.getAttributes());
                        newTag.setFlags(tag.getFlags());
                
                        tag = newTag;
                    }
                
                    if (HINT.RULE_TRIM_FIRST_LINE
                     && tag.getFlags() & RULE_TRIM_FIRST_LINE
                     && !tag.getEndTag()
                     && text[tag.getPos() + tag.getLen()] === "\n")
                    {
                        addIgnoreTag(tag.getPos() + tag.getLen(), 1);
                    }
                
                    // This tag is valid, output it and update the context
                    outputTag(tag);
                    pushContext(tag);
                
                    // Apply the createChild rules if applicable
                    createChild(tag);
                }
                
                /**
                * Process given end tag at current position
                *
                * @param {!Tag} tag End tag
                */
                function processEndTag(tag)
                {
                    var tagName = tag.getName();
                
                    if (!cntOpen[tagName])
                    {
                        // This is an end tag with no start tag
                        return;
                    }
                
                    /**
                    * @type {!Array.<!Tag>} List of tags need to be closed before given tag
                    */
                    var closeTags = [];
                
                    // Iterate through all open tags from last to first to find a match for our tag
                    var i = openTags.length;
                    while (--i >= 0)
                    {
                        var openTag = openTags[i];
                
                        if (tag.canClose(openTag))
                        {
                            break;
                        }
                
                        closeTags.push(openTag);
                        ++currentFixingCost;
                    }
                
                    if (i < 0)
                    {
                        // Did not find a matching tag
                        logger.debug('Skipping end tag with no start tag', {'tag': tag});
                
                        return;
                    }
                
                    // Accumulate flags to determine whether whitespace should be trimmed
                    var flags = tag.getFlags();
                    closeTags.forEach(function(openTag)
                    {
                        flags |= openTag.getFlags();
                    });
                    var ignoreWhitespace = (HINT.RULE_IGNORE_WHITESPACE && (flags & RULE_IGNORE_WHITESPACE));
                
                    // Only reopen tags if we haven't exceeded our "fixing" budget
                    var keepReopening = HINT.RULE_AUTO_REOPEN && (currentFixingCost < maxFixingCost),
                        reopenTags    = [];
                    closeTags.forEach(function(openTag)
                    {
                        var openTagName = openTag.getName();
                
                        // Test whether this tag should be reopened automatically
                        if (keepReopening)
                        {
                            if (openTag.getFlags() & RULE_AUTO_REOPEN)
                            {
                                reopenTags.push(openTag);
                            }
                            else
                            {
                                keepReopening = false;
                            }
                        }
                
                        // Find the earliest position we can close this open tag
                        var tagPos = tag.getPos();
                        if (ignoreWhitespace)
                        {
                            tagPos = getMagicEndPos(tagPos);
                        }
                
                        // Output an end tag to close this start tag, then update the context
                        var endTag = new Tag(Tag.END_TAG, openTagName, tagPos, 0);
                        endTag.setFlags(openTag.getFlags());
                        outputTag(endTag);
                        popContext();
                    });
                
                    // Output our tag, moving the cursor past it, then update the context
                    outputTag(tag);
                    popContext();
                
                    // If our fixing budget allows it, peek at upcoming tags and remove end tags that would
                    // close tags that are already being closed now. Also, filter our list of tags being
                    // reopened by removing those that would immediately be closed
                    if (closeTags.length && currentFixingCost < maxFixingCost)
                    {
                        /**
                        * @type {number} Rightmost position of the portion of text to ignore
                        */
                        var ignorePos = pos;
                
                        i = tagStack.length;
                        while (--i >= 0 && ++currentFixingCost < maxFixingCost)
                        {
                            var upcomingTag = tagStack[i];
                
                            // Test whether the upcoming tag is positioned at current "ignore" position and it's
                            // strictly an end tag (not a start tag or a self-closing tag)
                            if (upcomingTag.getPos() > ignorePos
                             || upcomingTag.isStartTag())
                            {
                                break;
                            }
                
                            // Test whether this tag would close any of the tags we're about to reopen
                            var j = closeTags.length;
                
                            while (--j >= 0 && ++currentFixingCost < maxFixingCost)
                            {
                                if (upcomingTag.canClose(closeTags[j]))
                                {
                                    // Remove the tag from the lists and reset the keys
                                    closeTags.splice(j, 1);
                
                                    if (reopenTags[j])
                                    {
                                        reopenTags.splice(j, 1);
                                    }
                
                                    // Extend the ignored text to cover this tag
                                    ignorePos = Math.max(
                                        ignorePos,
                                        upcomingTag.getPos() + upcomingTag.getLen()
                                    );
                
                                    break;
                                }
                            }
                        }
                
                        if (ignorePos > pos)
                        {
                            /**
                            * @todo have a method that takes (pos,len) rather than a Tag
                            */
                            outputIgnoreTag(new Tag(Tag.SELF_CLOSING_TAG, 'i', pos, ignorePos - pos));
                        }
                    }
                
                    // Re-add tags that need to be reopened, at current cursor position
                    reopenTags.forEach(function(startTag)
                    {
                        var newTag = addCopyTag(startTag, pos, 0);
                
                        // Re-pair the new tag
                        var endTag = startTag.getEndTag();
                        if (endTag)
                        {
                            newTag.pairWith(endTag);
                        }
                    });
                }
                
                /**
                * Update counters and replace current context with its parent context
                */
                function popContext()
                {
                    var tag = openTags.pop();
                    --cntOpen[tag.getName()];
                    context = context.parentContext;
                }
                
                /**
                * Update counters and replace current context with a new context based on given tag
                *
                * If given tag is a self-closing tag, the context won't change
                *
                * @param {!Tag} tag Start tag (including self-closing)
                */
                function pushContext(tag)
                {
                    var tagName   = tag.getName(),
                        tagFlags  = tag.getFlags(),
                        tagConfig = tagsConfig[tagName];
                
                    ++cntTotal[tagName];
                
                    // If this is a self-closing tag, the context remains the same
                    if (tag.isSelfClosingTag())
                    {
                        return;
                    }
                
                    // Recompute the allowed tags
                    var allowed = [];
                    if (HINT.RULE_IS_TRANSPARENT && (tagFlags & RULE_IS_TRANSPARENT))
                    {
                        context.allowed.forEach(function(v, k)
                        {
                            allowed.push(tagConfig.allowed[k] & v);
                        });
                    }
                    else
                    {
                        context.allowed.forEach(function(v, k)
                        {
                            allowed.push(tagConfig.allowed[k] & ((v & 0xFF00) | (v >> 8)));
                        });
                    }
                
                    // Use this tag's flags as a base for this context and add inherited rules
                    var flags = tagFlags | (context.flags & RULES_INHERITANCE);
                
                    // RULE_DISABLE_AUTO_BR turns off RULE_ENABLE_AUTO_BR
                    if (flags & RULE_DISABLE_AUTO_BR)
                    {
                        flags &= ~RULE_ENABLE_AUTO_BR;
                    }
                
                    ++cntOpen[tagName];
                    openTags.push(tag);
                    context = {
                        allowed       : allowed,
                        flags         : flags,
                        parentContext : context
                    };
                }
                
                /**
                * Return whether given tag is allowed in current context
                *
                * @param  {!string}  tagName
                * @return {!boolean}
                */
                function tagIsAllowed(tagName)
                {
                    var n = tagsConfig[tagName].bitNumber;
                
                    return !!(context.allowed[n >> 3] & (1 << (n & 7)));
                }
                
                //==========================================================================
                // Tag stack
                //==========================================================================
                
                /**
                * Add a start tag
                *
                * @param  {!string} name Name of the tag
                * @param  {!number} pos  Position of the tag in the text
                * @param  {!number} len  Length of text consumed by the tag
                * @param  {number=} prio Tags' priority
                * @return {!Tag}
                */
                function addStartTag(name, pos, len, prio)
                {
                    return addTag(Tag.START_TAG, name, pos, len, prio || 0);
                }
                
                /**
                * Add an end tag
                *
                * @param  {!string} name Name of the tag
                * @param  {!number} pos  Position of the tag in the text
                * @param  {!number} len  Length of text consumed by the tag
                * @param  {number=} prio Tags' priority
                * @return {!Tag}
                */
                function addEndTag(name, pos, len, prio)
                {
                    return addTag(Tag.END_TAG, name, pos, len, prio || 0);
                }
                
                /**
                * Add a self-closing tag
                *
                * @param  {!string} name Name of the tag
                * @param  {!number} pos  Position of the tag in the text
                * @param  {!number} len  Length of text consumed by the tag
                * @param  {number=} prio Tags' priority
                * @return {!Tag}
                */
                function addSelfClosingTag(name, pos, len, prio)
                {
                    return addTag(Tag.SELF_CLOSING_TAG, name, pos, len, prio || 0);
                }
                
                /**
                * Add a 0-width "br" tag to force a line break at given position
                *
                * @param  {!number} pos  Position of the tag in the text
                * @param  {number=} prio Tags' priority
                * @return {!Tag}
                */
                function addBrTag(pos, prio)
                {
                    return addTag(Tag.SELF_CLOSING_TAG, 'br', pos, 0, prio || 0);
                }
                
                /**
                * Add an "ignore" tag
                *
                * @param  {!number} pos  Position of the tag in the text
                * @param  {!number} len  Length of text consumed by the tag
                * @param  {number=} prio Tags' priority
                * @return {!Tag}
                */
                function addIgnoreTag(pos, len, prio)
                {
                    return addTag(Tag.SELF_CLOSING_TAG, 'i', pos, Math.min(len, textLen - pos), prio || 0);
                }
                
                /**
                * Add a paragraph break at given position
                *
                * Uses a zero-width tag that is actually never output in the result
                *
                * @param  {!number} pos  Position of the tag in the text
                * @param  {number=} prio Tags' priority
                * @return {!Tag}
                */
                function addParagraphBreak(pos, prio)
                {
                    return addTag(Tag.SELF_CLOSING_TAG, 'pb', pos, 0, prio || 0);
                }
                
                /**
                * Add a copy of given tag at given position and length
                *
                * @param  {!Tag}    tag Original tag
                * @param  {!number} pos Copy's position
                * @param  {!number} len Copy's length
                * @param  {number=} prio Tags' priority
                * @return {!Tag}         Copy tag
                */
                function addCopyTag(tag, pos, len, prio)
                {
                    var copy = addTag(tag.getType(), tag.getName(), pos, len, tag.getSortPriority());
                    copy.setAttributes(tag.getAttributes());
                
                    return copy;
                }
                
                /**
                * Add a tag
                *
                * @param  {!number} type Tag's type
                * @param  {!string} name Name of the tag
                * @param  {!number} pos  Position of the tag in the text
                * @param  {!number} len  Length of text consumed by the tag
                * @param  {number=} prio Tags' priority
                * @return {!Tag}
                */
                function addTag(type, name, pos, len, prio)
                {
                    // Create the tag
                    var tag = new Tag(type, name, pos, len, prio || 0);
                
                    // Set this tag's rules bitfield
                    if (tagsConfig[name])
                    {
                        tag.setFlags(tagsConfig[name].rules.flags);
                    }
                
                    // Invalidate this tag if it's an unknown tag, a disabled tag, if either of its length or
                    // position is negative or if it's out of bounds
                    if ((!tagsConfig[name] && !tag.isSystemTag()) || isInvalidTextSpan(pos, len))
                    {
                        tag.invalidate();
                    }
                    else if (tagsConfig[name] && tagsConfig[name].isDisabled)
                    {
                        logger.warn(
                            'Tag is disabled',
                            {
                                'tag'     : tag,
                                'tagName' : name
                            }
                        );
                        tag.invalidate();
                    }
                    else
                    {
                        insertTag(tag);
                    }
                
                    return tag;
                }
                
                /**
                * Test whether given text span is outside text boundaries or an invalid UTF sequence
                *
                * @param  {number}  pos Start of text
                * @param  {number}  len Length of text
                * @return {boolean}
                */
                function isInvalidTextSpan(pos, len)
                {
                    return (len < 0 || pos < 0 || pos + len > textLen || /[\uDC00-\uDFFF]/.test(text.substr(pos, 1) + text.substr(pos + len, 1)));
                }
                
                /**
                * Insert given tag in the tag stack
                *
                * @param {!Tag} tag
                */
                function insertTag(tag)
                {
                    if (!tagStackIsSorted)
                    {
                        tagStack.push(tag);
                    }
                    else
                    {
                        // Scan the stack and copy every tag to the next slot until we find the correct index
                        var i = tagStack.length;
                        while (i > 0 && compareTags(tagStack[i - 1], tag) > 0)
                        {
                            tagStack[i] = tagStack[i - 1];
                            --i;
                        }
                        tagStack[i] = tag;
                    }
                }
                
                /**
                * Add a pair of tags
                *
                * @param  {!string} name     Name of the tags
                * @param  {!number} startPos Position of the start tag
                * @param  {!number} startLen Length of the start tag
                * @param  {!number} endPos   Position of the start tag
                * @param  {!number} endLen   Length of the start tag
                * @param  {number=}  prio     Start tag's priority (the end tag will be set to minus that value)
                * @return {!Tag}             Start tag
                */
                function addTagPair(name, startPos, startLen, endPos, endLen, prio)
                {
                    // NOTE: the end tag is added first to try to keep the stack in the correct order
                    var endTag   = addEndTag(name, endPos, endLen, -prio || 0),
                        startTag = addStartTag(name, startPos, startLen, prio || 0);
                    startTag.pairWith(endTag);
                
                    return startTag;
                }
                
                /**
                * Add a tag that represents a verbatim copy of the original text
                *
                * @param  {!number} pos  Position of the tag in the text
                * @param  {!number} len  Length of text consumed by the tag
                * @return {!Tag}
                */
                function addVerbatim(pos, len, prio)
                {
                    return addTag(Tag.SELF_CLOSING_TAG, 'v', pos, len, prio || 0);
                }
                
                /**
                * Sort tags by position and precedence
                */
                function sortTags()
                {
                    tagStack.sort(compareTags);
                    tagStackIsSorted = true;
                }
                
                /**
                * sortTags() callback
                *
                * Tags are stored as a stack, in LIFO order. We sort tags by position _descending_ so that they
                * are processed in the order they appear in the text.
                *
                * @param  {!Tag}    a First tag to compare
                * @param  {!Tag}    b Second tag to compare
                * @return {!number}
                */
                function compareTags(a, b)
                {
                    var aPos = a.getPos(),
                        bPos = b.getPos();
                
                    // First we order by pos descending
                    if (aPos !== bPos)
                    {
                        return bPos - aPos;
                    }
                
                    // If the tags start at the same position, we'll use their sortPriority if applicable. Tags
                    // with a lower value get sorted last, which means they'll be processed first. IOW, -10 is
                    // processed before 10
                    if (a.getSortPriority() !== b.getSortPriority())
                    {
                        return b.getSortPriority() - a.getSortPriority();
                    }
                
                    // If the tags start at the same position and have the same priority, we'll sort them
                    // according to their length, with special considerations for  zero-width tags
                    var aLen = a.getLen(),
                        bLen = b.getLen();
                
                    if (!aLen || !bLen)
                    {
                        // Zero-width end tags are ordered after zero-width start tags so that a pair that ends
                        // with a zero-width tag has the opportunity to be closed before another pair starts
                        // with a zero-width tag. For example, the pairs that would enclose each of the letters
                        // in the string "XY". Self-closing tags are ordered between end tags and start tags in
                        // an attempt to keep them out of tag pairs
                        if (!aLen && !bLen)
                        {
                            var order = {};
                            order[Tag.END_TAG]          = 0;
                            order[Tag.SELF_CLOSING_TAG] = 1;
                            order[Tag.START_TAG]        = 2;
                
                            return order[b.getType()] - order[a.getType()];
                        }
                
                        // Here, we know that only one of a or b is a zero-width tags. Zero-width tags are
                        // ordered after wider tags so that they have a chance to be processed before the next
                        // character is consumed, which would force them to be skipped
                        return (aLen) ? -1 : 1;
                    }
                
                    // Here we know that both tags start at the same position and have a length greater than 0.
                    // We sort tags by length ascending, so that the longest matches are processed first. If
                    // their length is identical, the order is undefined as PHP's sort isn't stable
                    return aLen - bLen;
                }
                var MSXML = (typeof DOMParser === 'undefined' || typeof XSLTProcessor === 'undefined');
                var xslt = {
                    /**
                    * @param {!string} xsl
                    */
                    init: function(xsl)
                    {
                        var stylesheet = xslt.loadXML(xsl, 'MSXML2.FreeThreadedDOMDocument.6.0');
                        if (MSXML)
                        {
                            var generator = new ActiveXObject('MSXML2.XSLTemplate.6.0');
                            generator['stylesheet'] = stylesheet;
                            xslt.proc = generator['createProcessor']();
                        }
                        else
                        {
                            xslt.proc = new XSLTProcessor;
                            xslt.proc['importStylesheet'](stylesheet);
                        }
                    },
                
                    /**
                    * @param {!string} xml
                    * @param {string} type
                    */
                    loadXML: function(xml, type)
                    {
                        if (MSXML)
                        {
                            var dom = new ActiveXObject(type);
                            dom['async'] = false;
                            dom['validateOnParse'] = false;
                            dom['loadXML'](xml);
                
                            return dom;
                        }
                
                        return (new DOMParser).parseFromString(xml, 'text/xml');
                    },
                
                    /**
                    * @param {!string} paramName  Parameter name
                    * @param {!string} paramValue Parameter's value
                    */
                    setParameter: function(paramName, paramValue)
                    {
                        if (MSXML)
                        {
                            xslt.proc['addParameter'](paramName, paramValue, '');
                        }
                        else
                        {
                            xslt.proc['setParameter'](null, paramName, paramValue);
                        }
                    },
                
                    /**
                    * @param {!string} xml
                    * @param {!HTMLDocument} targetDoc
                    */
                    transformToFragment: function(xml, targetDoc)
                    {
                        if (MSXML)
                        {
                            var div = targetDoc.createElement('div'),
                                fragment = targetDoc.createDocumentFragment();
                
                            xslt.proc['input'] = xslt.loadXML(xml, 'MSXML2.DOMDocument.6.0');
                            xslt.proc['transform']();
                            div.innerHTML = xslt.proc['output'];
                            while (div.firstChild)
                            {
                                fragment.appendChild(div.firstChild);
                            }
                
                            return fragment;
                        }
                
                        // NOTE: importNode() is used because of https://code.google.com/p/chromium/issues/detail?id=266305
                        return targetDoc.importNode(xslt.proc['transformToFragment'](xslt.loadXML(xml), targetDoc), true);
                    }
                }
                xslt.init(xsl);
                
                var postProcessFunctions = {};
                
                /**
                * Parse a given text and render it into given HTML element
                *
                * @param  {!string} text
                * @param  {!HTMLElement} target
                * @return {!Node}
                */
                function preview(text, target)
                {
                    var targetDoc      = target.ownerDocument,
                        resultFragment = xslt.transformToFragment(parse(text).replace(/<[eis]>.*?<\/[eis]>/g, ''), targetDoc),
                        lastUpdated    = target;
                
                    // Apply post-processing
                    if (HINT.postProcessing)
                    {
                        var nodes = resultFragment['querySelectorAll']('[data-s9e-livepreview-postprocess]'),
                            i     = nodes.length;
                        while (--i >= 0)
                        {
                            /** @type {!string} */
                            var code = nodes[i]['getAttribute']('data-s9e-livepreview-postprocess');
                            if (!postProcessFunctions[code])
                            {
                                postProcessFunctions[code] = new Function(code);
                            }
                
                            postProcessFunctions[code]['call'](nodes[i]);
                        }
                    }
                
                    /**
                    * Update the content of given element oldEl to match element newEl
                    *
                    * @param {!HTMLElement} oldEl
                    * @param {!HTMLElement} newEl
                    */
                    function refreshElementContent(oldEl, newEl)
                    {
                        var oldNodes = oldEl.childNodes,
                            newNodes = newEl.childNodes,
                            oldCnt   = oldNodes.length,
                            newCnt   = newNodes.length,
                            oldNode,
                            newNode,
                            left     = 0,
                            right    = 0;
                
                        // Skip the leftmost matching nodes
                        while (left < oldCnt && left < newCnt)
                        {
                            oldNode = oldNodes[left];
                            newNode = newNodes[left];
                            if (!refreshNode(oldNode, newNode))
                            {
                                break;
                            }
                
                            ++left;
                        }
                
                        // Skip the rightmost matching nodes
                        var maxRight = Math.min(oldCnt - left, newCnt - left);
                        while (right < maxRight)
                        {
                            oldNode = oldNodes[oldCnt - (right + 1)];
                            newNode = newNodes[newCnt - (right + 1)];
                            if (!refreshNode(oldNode, newNode))
                            {
                                break;
                            }
                
                            ++right;
                        }
                
                        // Remove the old dirty nodes in the middle of the tree
                        var i = oldCnt - right;
                        while (--i >= left)
                        {
                            oldEl.removeChild(oldNodes[i]);
                            lastUpdated = oldEl;
                        }
                
                        // Test whether there are any nodes in the new tree between the matching nodes at the left
                        // and the matching nodes at the right
                        var rightBoundary = newCnt - right;
                        if (left >= rightBoundary)
                        {
                            return;
                        }
                
                        // Clone the new nodes
                        var newNodesFragment = targetDoc.createDocumentFragment();
                        i = left;
                        do
                        {
                            newNodesFragment.appendChild(newNodes[i]);
                        }
                        while (i < --rightBoundary);
                
                        // If we haven't skipped any nodes to the right, we can just append the fragment
                        if (!right)
                        {
                            oldEl.appendChild(newNodesFragment);
                            lastUpdated = oldEl.lastChild;
                        }
                        else
                        {
                            var beforeNode = oldEl.childNodes[left];
                            oldEl.insertBefore(newNodesFragment, beforeNode);
                            lastUpdated = beforeNode.previousChild;
                        }
                    }
                
                    /**
                    * Update given node oldNode to make it match newNode
                    *
                    * @param {!HTMLElement} oldNode
                    * @param {!HTMLElement} newNode
                    * @return boolean Whether the node can be skipped
                    */
                    function refreshNode(oldNode, newNode)
                    {
                        if (oldNode.nodeName !== newNode.nodeName
                         || oldNode.nodeType !== newNode.nodeType)
                        {
                            return false;
                        }
                
                        // Node.TEXT_NODE || Node.COMMENT_NODE
                        if (oldNode.nodeType === 3 || oldNode.nodeType === 8)
                        {
                            if (oldNode.nodeValue !== newNode.nodeValue)
                            {
                                oldNode.nodeValue = newNode.nodeValue;
                                lastUpdated = oldNode;
                            }
                
                            return true;
                        }
                
                        if (oldNode.isEqualNode && oldNode.isEqualNode(newNode))
                        {
                            return true;
                        }
                
                        syncElementAttributes(oldNode, newNode);
                        refreshElementContent(oldNode, newNode);
                
                        return true;
                    }
                
                    /**
                    * Make the set of attributes of given element oldEl match newEl's
                    *
                    * @param {!HTMLElement} oldEl
                    * @param {!HTMLElement} newEl
                    */
                    function syncElementAttributes(oldEl, newEl)
                    {
                        var oldAttributes = oldEl['attributes'],
                            newAttributes = newEl['attributes'],
                            oldCnt        = oldAttributes.length,
                            newCnt        = newAttributes.length,
                            i             = oldCnt,
                            ignoreAttrs   = ' ' + oldAttributes['data-s9e-livepreview-ignore-attrs'] + ' ';
                
                        while (--i >= 0)
                        {
                            var oldAttr      = oldAttributes[i],
                                namespaceURI = oldAttr['namespaceURI'],
                                attrName     = oldAttr['name'];
                
                            if (HINT.ignoreAttrs && ignoreAttrs.indexOf(' ' + attrName + ' ') > -1)
                            {
                                continue;
                            }
                            if (!newEl.hasAttributeNS(namespaceURI, attrName))
                            {
                                oldEl.removeAttributeNS(namespaceURI, attrName);
                                lastUpdated = oldEl;
                            }
                        }
                
                        i = newCnt;
                        while (--i >= 0)
                        {
                            var newAttr      = newAttributes[i],
                                namespaceURI = newAttr['namespaceURI'],
                                attrName     = newAttr['name'],
                                attrValue    = newAttr['value'];
                
                            if (HINT.ignoreAttrs && ignoreAttrs.indexOf(' ' + attrName + ' ') > -1)
                            {
                                continue;
                            }
                            if (attrValue !== oldEl.getAttributeNS(namespaceURI, attrName))
                            {
                                oldEl.setAttributeNS(namespaceURI, attrName, attrValue);
                                lastUpdated = oldEl;
                            }
                        }
                    }
                
                    refreshElementContent(target, resultFragment);
                
                    return lastUpdated;
                }
                
                /**
                * Set the value of a stylesheet parameter
                *
                * @param {!string} paramName  Parameter name
                * @param {!string} paramValue Parameter's value
                */
                function setParameter(paramName, paramValue)
                {
                    xslt.setParameter(paramName, paramValue);
                }if (!window['s9e']) window['s9e'] = {};
                window['s9e']['TextFormatter'] = {'preview':preview}})()</script>
    </body>
</html>